This is libc.info, produced by makeinfo version 4.13 from libc.texinfo.

INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* Libc: (libc).                 C library.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION GNU C library functions and macros
START-INFO-DIR-ENTRY
* ALTWERASE: (libc)Local Modes.
* ARGP_ERR_UNKNOWN: (libc)Argp Parser Functions.
* ARG_MAX: (libc)General Limits.
* BC_BASE_MAX: (libc)Utility Limits.
* BC_DIM_MAX: (libc)Utility Limits.
* BC_SCALE_MAX: (libc)Utility Limits.
* BC_STRING_MAX: (libc)Utility Limits.
* BRKINT: (libc)Input Modes.
* BUFSIZ: (libc)Controlling Buffering.
* CCTS_OFLOW: (libc)Control Modes.
* CHILD_MAX: (libc)General Limits.
* CIGNORE: (libc)Control Modes.
* CLK_TCK: (libc)CPU Time.
* CLOCAL: (libc)Control Modes.
* CLOCKS_PER_SEC: (libc)CPU Time.
* COLL_WEIGHTS_MAX: (libc)Utility Limits.
* CPU_CLR: (libc)CPU Affinity.
* CPU_ISSET: (libc)CPU Affinity.
* CPU_SET: (libc)CPU Affinity.
* CPU_SETSIZE: (libc)CPU Affinity.
* CPU_ZERO: (libc)CPU Affinity.
* CREAD: (libc)Control Modes.
* CRTS_IFLOW: (libc)Control Modes.
* CS5: (libc)Control Modes.
* CS6: (libc)Control Modes.
* CS7: (libc)Control Modes.
* CS8: (libc)Control Modes.
* CSIZE: (libc)Control Modes.
* CSTOPB: (libc)Control Modes.
* DES_FAILED: (libc)DES Encryption.
* DTTOIF: (libc)Directory Entries.
* E2BIG: (libc)Error Codes.
* EACCES: (libc)Error Codes.
* EADDRINUSE: (libc)Error Codes.
* EADDRNOTAVAIL: (libc)Error Codes.
* EADV: (libc)Error Codes.
* EAFNOSUPPORT: (libc)Error Codes.
* EAGAIN: (libc)Error Codes.
* EALREADY: (libc)Error Codes.
* EAUTH: (libc)Error Codes.
* EBACKGROUND: (libc)Error Codes.
* EBADE: (libc)Error Codes.
* EBADF: (libc)Error Codes.
* EBADFD: (libc)Error Codes.
* EBADMSG: (libc)Error Codes.
* EBADR: (libc)Error Codes.
* EBADRPC: (libc)Error Codes.
* EBADRQC: (libc)Error Codes.
* EBADSLT: (libc)Error Codes.
* EBFONT: (libc)Error Codes.
* EBUSY: (libc)Error Codes.
* ECANCELED: (libc)Error Codes.
* ECHILD: (libc)Error Codes.
* ECHO: (libc)Local Modes.
* ECHOCTL: (libc)Local Modes.
* ECHOE: (libc)Local Modes.
* ECHOK: (libc)Local Modes.
* ECHOKE: (libc)Local Modes.
* ECHONL: (libc)Local Modes.
* ECHOPRT: (libc)Local Modes.
* ECHRNG: (libc)Error Codes.
* ECOMM: (libc)Error Codes.
* ECONNABORTED: (libc)Error Codes.
* ECONNREFUSED: (libc)Error Codes.
* ECONNRESET: (libc)Error Codes.
* ED: (libc)Error Codes.
* EDEADLK: (libc)Error Codes.
* EDEADLOCK: (libc)Error Codes.
* EDESTADDRREQ: (libc)Error Codes.
* EDIED: (libc)Error Codes.
* EDOM: (libc)Error Codes.
* EDOTDOT: (libc)Error Codes.
* EDQUOT: (libc)Error Codes.
* EEXIST: (libc)Error Codes.
* EFAULT: (libc)Error Codes.
* EFBIG: (libc)Error Codes.
* EFTYPE: (libc)Error Codes.
* EGRATUITOUS: (libc)Error Codes.
* EGREGIOUS: (libc)Error Codes.
* EHOSTDOWN: (libc)Error Codes.
* EHOSTUNREACH: (libc)Error Codes.
* EIDRM: (libc)Error Codes.
* EIEIO: (libc)Error Codes.
* EILSEQ: (libc)Error Codes.
* EINPROGRESS: (libc)Error Codes.
* EINTR: (libc)Error Codes.
* EINVAL: (libc)Error Codes.
* EIO: (libc)Error Codes.
* EISCONN: (libc)Error Codes.
* EISDIR: (libc)Error Codes.
* EISNAM: (libc)Error Codes.
* EKEYEXPIRED: (libc)Error Codes.
* EKEYREJECTED: (libc)Error Codes.
* EKEYREVOKED: (libc)Error Codes.
* EL2HLT: (libc)Error Codes.
* EL2NSYNC: (libc)Error Codes.
* EL3HLT: (libc)Error Codes.
* EL3RST: (libc)Error Codes.
* ELIBACC: (libc)Error Codes.
* ELIBBAD: (libc)Error Codes.
* ELIBEXEC: (libc)Error Codes.
* ELIBMAX: (libc)Error Codes.
* ELIBSCN: (libc)Error Codes.
* ELNRNG: (libc)Error Codes.
* ELOOP: (libc)Error Codes.
* EMEDIUMTYPE: (libc)Error Codes.
* EMFILE: (libc)Error Codes.
* EMLINK: (libc)Error Codes.
* EMSGSIZE: (libc)Error Codes.
* EMULTIHOP: (libc)Error Codes.
* ENAMETOOLONG: (libc)Error Codes.
* ENAVAIL: (libc)Error Codes.
* ENEEDAUTH: (libc)Error Codes.
* ENETDOWN: (libc)Error Codes.
* ENETRESET: (libc)Error Codes.
* ENETUNREACH: (libc)Error Codes.
* ENFILE: (libc)Error Codes.
* ENOANO: (libc)Error Codes.
* ENOBUFS: (libc)Error Codes.
* ENOCSI: (libc)Error Codes.
* ENODATA: (libc)Error Codes.
* ENODEV: (libc)Error Codes.
* ENOENT: (libc)Error Codes.
* ENOEXEC: (libc)Error Codes.
* ENOKEY: (libc)Error Codes.
* ENOLCK: (libc)Error Codes.
* ENOLINK: (libc)Error Codes.
* ENOMEDIUM: (libc)Error Codes.
* ENOMEM: (libc)Error Codes.
* ENOMSG: (libc)Error Codes.
* ENONET: (libc)Error Codes.
* ENOPKG: (libc)Error Codes.
* ENOPROTOOPT: (libc)Error Codes.
* ENOSPC: (libc)Error Codes.
* ENOSR: (libc)Error Codes.
* ENOSTR: (libc)Error Codes.
* ENOSYS: (libc)Error Codes.
* ENOTBLK: (libc)Error Codes.
* ENOTCONN: (libc)Error Codes.
* ENOTDIR: (libc)Error Codes.
* ENOTEMPTY: (libc)Error Codes.
* ENOTNAM: (libc)Error Codes.
* ENOTRECOVERABLE: (libc)Error Codes.
* ENOTSOCK: (libc)Error Codes.
* ENOTSUP: (libc)Error Codes.
* ENOTTY: (libc)Error Codes.
* ENOTUNIQ: (libc)Error Codes.
* ENXIO: (libc)Error Codes.
* EOF: (libc)EOF and Errors.
* EOPNOTSUPP: (libc)Error Codes.
* EOVERFLOW: (libc)Error Codes.
* EOWNERDEAD: (libc)Error Codes.
* EPERM: (libc)Error Codes.
* EPFNOSUPPORT: (libc)Error Codes.
* EPIPE: (libc)Error Codes.
* EPROCLIM: (libc)Error Codes.
* EPROCUNAVAIL: (libc)Error Codes.
* EPROGMISMATCH: (libc)Error Codes.
* EPROGUNAVAIL: (libc)Error Codes.
* EPROTO: (libc)Error Codes.
* EPROTONOSUPPORT: (libc)Error Codes.
* EPROTOTYPE: (libc)Error Codes.
* EQUIV_CLASS_MAX: (libc)Utility Limits.
* ERANGE: (libc)Error Codes.
* EREMCHG: (libc)Error Codes.
* EREMOTE: (libc)Error Codes.
* EREMOTEIO: (libc)Error Codes.
* ERESTART: (libc)Error Codes.
* EROFS: (libc)Error Codes.
* ERPCMISMATCH: (libc)Error Codes.
* ESHUTDOWN: (libc)Error Codes.
* ESOCKTNOSUPPORT: (libc)Error Codes.
* ESPIPE: (libc)Error Codes.
* ESRCH: (libc)Error Codes.
* ESRMNT: (libc)Error Codes.
* ESTALE: (libc)Error Codes.
* ESTRPIPE: (libc)Error Codes.
* ETIME: (libc)Error Codes.
* ETIMEDOUT: (libc)Error Codes.
* ETOOMANYREFS: (libc)Error Codes.
* ETXTBSY: (libc)Error Codes.
* EUCLEAN: (libc)Error Codes.
* EUNATCH: (libc)Error Codes.
* EUSERS: (libc)Error Codes.
* EWOULDBLOCK: (libc)Error Codes.
* EXDEV: (libc)Error Codes.
* EXFULL: (libc)Error Codes.
* EXIT_FAILURE: (libc)Exit Status.
* EXIT_SUCCESS: (libc)Exit Status.
* EXPR_NEST_MAX: (libc)Utility Limits.
* FD_CLOEXEC: (libc)Descriptor Flags.
* FD_CLR: (libc)Waiting for I/O.
* FD_ISSET: (libc)Waiting for I/O.
* FD_SET: (libc)Waiting for I/O.
* FD_SETSIZE: (libc)Waiting for I/O.
* FD_ZERO: (libc)Waiting for I/O.
* FILENAME_MAX: (libc)Limits for Files.
* FLUSHO: (libc)Local Modes.
* FOPEN_MAX: (libc)Opening Streams.
* FP_ILOGB0: (libc)Exponents and Logarithms.
* FP_ILOGBNAN: (libc)Exponents and Logarithms.
* F_DUPFD: (libc)Duplicating Descriptors.
* F_GETFD: (libc)Descriptor Flags.
* F_GETFL: (libc)Getting File Status Flags.
* F_GETLK: (libc)File Locks.
* F_GETOWN: (libc)Interrupt Input.
* F_OK: (libc)Testing File Access.
* F_SETFD: (libc)Descriptor Flags.
* F_SETFL: (libc)Getting File Status Flags.
* F_SETLK: (libc)File Locks.
* F_SETLKW: (libc)File Locks.
* F_SETOWN: (libc)Interrupt Input.
* HUGE_VAL: (libc)Math Error Reporting.
* HUGE_VALF: (libc)Math Error Reporting.
* HUGE_VALL: (libc)Math Error Reporting.
* HUPCL: (libc)Control Modes.
* I: (libc)Complex Numbers.
* ICANON: (libc)Local Modes.
* ICRNL: (libc)Input Modes.
* IEXTEN: (libc)Local Modes.
* IFNAMSIZ: (libc)Interface Naming.
* IFTODT: (libc)Directory Entries.
* IGNBRK: (libc)Input Modes.
* IGNCR: (libc)Input Modes.
* IGNPAR: (libc)Input Modes.
* IMAXBEL: (libc)Input Modes.
* INADDR_ANY: (libc)Host Address Data Type.
* INADDR_BROADCAST: (libc)Host Address Data Type.
* INADDR_LOOPBACK: (libc)Host Address Data Type.
* INADDR_NONE: (libc)Host Address Data Type.
* INFINITY: (libc)Infinity and NaN.
* INLCR: (libc)Input Modes.
* INPCK: (libc)Input Modes.
* IPPORT_RESERVED: (libc)Ports.
* IPPORT_USERRESERVED: (libc)Ports.
* ISIG: (libc)Local Modes.
* ISTRIP: (libc)Input Modes.
* IXANY: (libc)Input Modes.
* IXOFF: (libc)Input Modes.
* IXON: (libc)Input Modes.
* LINE_MAX: (libc)Utility Limits.
* LINK_MAX: (libc)Limits for Files.
* L_ctermid: (libc)Identifying the Terminal.
* L_cuserid: (libc)Who Logged In.
* L_tmpnam: (libc)Temporary Files.
* MAXNAMLEN: (libc)Limits for Files.
* MAXSYMLINKS: (libc)Symbolic Links.
* MAX_CANON: (libc)Limits for Files.
* MAX_INPUT: (libc)Limits for Files.
* MB_CUR_MAX: (libc)Selecting the Conversion.
* MB_LEN_MAX: (libc)Selecting the Conversion.
* MDMBUF: (libc)Control Modes.
* MSG_DONTROUTE: (libc)Socket Data Options.
* MSG_OOB: (libc)Socket Data Options.
* MSG_PEEK: (libc)Socket Data Options.
* NAME_MAX: (libc)Limits for Files.
* NAN: (libc)Infinity and NaN.
* NCCS: (libc)Mode Data Types.
* NGROUPS_MAX: (libc)General Limits.
* NOFLSH: (libc)Local Modes.
* NOKERNINFO: (libc)Local Modes.
* NSIG: (libc)Standard Signals.
* NULL: (libc)Null Pointer Constant.
* ONLCR: (libc)Output Modes.
* ONOEOT: (libc)Output Modes.
* OPEN_MAX: (libc)General Limits.
* OPOST: (libc)Output Modes.
* OXTABS: (libc)Output Modes.
* O_ACCMODE: (libc)Access Modes.
* O_APPEND: (libc)Operating Modes.
* O_ASYNC: (libc)Operating Modes.
* O_CREAT: (libc)Open-time Flags.
* O_EXCL: (libc)Open-time Flags.
* O_EXEC: (libc)Access Modes.
* O_EXLOCK: (libc)Open-time Flags.
* O_FSYNC: (libc)Operating Modes.
* O_IGNORE_CTTY: (libc)Open-time Flags.
* O_NDELAY: (libc)Operating Modes.
* O_NOATIME: (libc)Operating Modes.
* O_NOCTTY: (libc)Open-time Flags.
* O_NOLINK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Operating Modes.
* O_NOTRANS: (libc)Open-time Flags.
* O_RDONLY: (libc)Access Modes.
* O_RDWR: (libc)Access Modes.
* O_READ: (libc)Access Modes.
* O_SHLOCK: (libc)Open-time Flags.
* O_SYNC: (libc)Operating Modes.
* O_TRUNC: (libc)Open-time Flags.
* O_WRITE: (libc)Access Modes.
* O_WRONLY: (libc)Access Modes.
* PARENB: (libc)Control Modes.
* PARMRK: (libc)Input Modes.
* PARODD: (libc)Control Modes.
* PATH_MAX: (libc)Limits for Files.
* PA_FLAG_MASK: (libc)Parsing a Template String.
* PENDIN: (libc)Local Modes.
* PF_FILE: (libc)Local Namespace Details.
* PF_INET6: (libc)Internet Namespace.
* PF_INET: (libc)Internet Namespace.
* PF_LOCAL: (libc)Local Namespace Details.
* PF_UNIX: (libc)Local Namespace Details.
* PIPE_BUF: (libc)Limits for Files.
* P_tmpdir: (libc)Temporary Files.
* RAND_MAX: (libc)ISO Random.
* RE_DUP_MAX: (libc)General Limits.
* RLIM_INFINITY: (libc)Limits on Resources.
* R_OK: (libc)Testing File Access.
* SA_NOCLDSTOP: (libc)Flags for Sigaction.
* SA_ONSTACK: (libc)Flags for Sigaction.
* SA_RESTART: (libc)Flags for Sigaction.
* SEEK_CUR: (libc)File Positioning.
* SEEK_END: (libc)File Positioning.
* SEEK_SET: (libc)File Positioning.
* SIGABRT: (libc)Program Error Signals.
* SIGALRM: (libc)Alarm Signals.
* SIGBUS: (libc)Program Error Signals.
* SIGCHLD: (libc)Job Control Signals.
* SIGCLD: (libc)Job Control Signals.
* SIGCONT: (libc)Job Control Signals.
* SIGEMT: (libc)Program Error Signals.
* SIGFPE: (libc)Program Error Signals.
* SIGHUP: (libc)Termination Signals.
* SIGILL: (libc)Program Error Signals.
* SIGINFO: (libc)Miscellaneous Signals.
* SIGINT: (libc)Termination Signals.
* SIGIO: (libc)Asynchronous I/O Signals.
* SIGIOT: (libc)Program Error Signals.
* SIGKILL: (libc)Termination Signals.
* SIGLOST: (libc)Operation Error Signals.
* SIGPIPE: (libc)Operation Error Signals.
* SIGPOLL: (libc)Asynchronous I/O Signals.
* SIGPROF: (libc)Alarm Signals.
* SIGQUIT: (libc)Termination Signals.
* SIGSEGV: (libc)Program Error Signals.
* SIGSTOP: (libc)Job Control Signals.
* SIGSYS: (libc)Program Error Signals.
* SIGTERM: (libc)Termination Signals.
* SIGTRAP: (libc)Program Error Signals.
* SIGTSTP: (libc)Job Control Signals.
* SIGTTIN: (libc)Job Control Signals.
* SIGTTOU: (libc)Job Control Signals.
* SIGURG: (libc)Asynchronous I/O Signals.
* SIGUSR1: (libc)Miscellaneous Signals.
* SIGUSR2: (libc)Miscellaneous Signals.
* SIGVTALRM: (libc)Alarm Signals.
* SIGWINCH: (libc)Miscellaneous Signals.
* SIGXCPU: (libc)Operation Error Signals.
* SIGXFSZ: (libc)Operation Error Signals.
* SIG_ERR: (libc)Basic Signal Handling.
* SOCK_DGRAM: (libc)Communication Styles.
* SOCK_RAW: (libc)Communication Styles.
* SOCK_RDM: (libc)Communication Styles.
* SOCK_SEQPACKET: (libc)Communication Styles.
* SOCK_STREAM: (libc)Communication Styles.
* SOL_SOCKET: (libc)Socket-Level Options.
* SSIZE_MAX: (libc)General Limits.
* STREAM_MAX: (libc)General Limits.
* SUN_LEN: (libc)Local Namespace Details.
* SV_INTERRUPT: (libc)BSD Handler.
* SV_ONSTACK: (libc)BSD Handler.
* SV_RESETHAND: (libc)BSD Handler.
* S_IFMT: (libc)Testing File Type.
* S_ISBLK: (libc)Testing File Type.
* S_ISCHR: (libc)Testing File Type.
* S_ISDIR: (libc)Testing File Type.
* S_ISFIFO: (libc)Testing File Type.
* S_ISLNK: (libc)Testing File Type.
* S_ISREG: (libc)Testing File Type.
* S_ISSOCK: (libc)Testing File Type.
* S_TYPEISMQ: (libc)Testing File Type.
* S_TYPEISSEM: (libc)Testing File Type.
* S_TYPEISSHM: (libc)Testing File Type.
* TMP_MAX: (libc)Temporary Files.
* TOSTOP: (libc)Local Modes.
* TZNAME_MAX: (libc)General Limits.
* VDISCARD: (libc)Other Special.
* VDSUSP: (libc)Signal Characters.
* VEOF: (libc)Editing Characters.
* VEOL2: (libc)Editing Characters.
* VEOL: (libc)Editing Characters.
* VERASE: (libc)Editing Characters.
* VINTR: (libc)Signal Characters.
* VKILL: (libc)Editing Characters.
* VLNEXT: (libc)Other Special.
* VMIN: (libc)Noncanonical Input.
* VQUIT: (libc)Signal Characters.
* VREPRINT: (libc)Editing Characters.
* VSTART: (libc)Start/Stop Characters.
* VSTATUS: (libc)Other Special.
* VSTOP: (libc)Start/Stop Characters.
* VSUSP: (libc)Signal Characters.
* VTIME: (libc)Noncanonical Input.
* VWERASE: (libc)Editing Characters.
* WCHAR_MAX: (libc)Extended Char Intro.
* WCHAR_MIN: (libc)Extended Char Intro.
* WCOREDUMP: (libc)Process Completion Status.
* WEOF: (libc)EOF and Errors.
* WEOF: (libc)Extended Char Intro.
* WEXITSTATUS: (libc)Process Completion Status.
* WIFEXITED: (libc)Process Completion Status.
* WIFSIGNALED: (libc)Process Completion Status.
* WIFSTOPPED: (libc)Process Completion Status.
* WSTOPSIG: (libc)Process Completion Status.
* WTERMSIG: (libc)Process Completion Status.
* W_OK: (libc)Testing File Access.
* X_OK: (libc)Testing File Access.
* _Complex_I: (libc)Complex Numbers.
* _Exit: (libc)Termination Internals.
* _IOFBF: (libc)Controlling Buffering.
* _IOLBF: (libc)Controlling Buffering.
* _IONBF: (libc)Controlling Buffering.
* _Imaginary_I: (libc)Complex Numbers.
* _PATH_UTMP: (libc)Manipulating the Database.
* _PATH_WTMP: (libc)Manipulating the Database.
* _POSIX2_C_DEV: (libc)System Options.
* _POSIX2_C_VERSION: (libc)Version Supported.
* _POSIX2_FORT_DEV: (libc)System Options.
* _POSIX2_FORT_RUN: (libc)System Options.
* _POSIX2_LOCALEDEF: (libc)System Options.
* _POSIX2_SW_DEV: (libc)System Options.
* _POSIX_CHOWN_RESTRICTED: (libc)Options for Files.
* _POSIX_JOB_CONTROL: (libc)System Options.
* _POSIX_NO_TRUNC: (libc)Options for Files.
* _POSIX_SAVED_IDS: (libc)System Options.
* _POSIX_VDISABLE: (libc)Options for Files.
* _POSIX_VERSION: (libc)Version Supported.
* __fbufsize: (libc)Controlling Buffering.
* __flbf: (libc)Controlling Buffering.
* __fpending: (libc)Controlling Buffering.
* __fpurge: (libc)Flushing Buffers.
* __freadable: (libc)Opening Streams.
* __freading: (libc)Opening Streams.
* __fsetlocking: (libc)Streams and Threads.
* __fwritable: (libc)Opening Streams.
* __fwriting: (libc)Opening Streams.
* __gconv_end_fct: (libc)glibc iconv Implementation.
* __gconv_fct: (libc)glibc iconv Implementation.
* __gconv_init_fct: (libc)glibc iconv Implementation.
* __va_copy: (libc)Argument Macros.
* _exit: (libc)Termination Internals.
* _flushlbf: (libc)Flushing Buffers.
* _tolower: (libc)Case Conversion.
* _toupper: (libc)Case Conversion.
* a64l: (libc)Encode Binary Data.
* abort: (libc)Aborting a Program.
* abs: (libc)Absolute Value.
* accept: (libc)Accepting Connections.
* access: (libc)Testing File Access.
* acos: (libc)Inverse Trig Functions.
* acosf: (libc)Inverse Trig Functions.
* acosh: (libc)Hyperbolic Functions.
* acoshf: (libc)Hyperbolic Functions.
* acoshl: (libc)Hyperbolic Functions.
* acosl: (libc)Inverse Trig Functions.
* addmntent: (libc)mtab.
* addseverity: (libc)Adding Severity Classes.
* adjtime: (libc)High-Resolution Calendar.
* adjtimex: (libc)High-Resolution Calendar.
* aio_cancel64: (libc)Cancel AIO Operations.
* aio_cancel: (libc)Cancel AIO Operations.
* aio_error64: (libc)Status of AIO Operations.
* aio_error: (libc)Status of AIO Operations.
* aio_fsync64: (libc)Synchronizing AIO Operations.
* aio_fsync: (libc)Synchronizing AIO Operations.
* aio_init: (libc)Configuration of AIO.
* aio_read64: (libc)Asynchronous Reads/Writes.
* aio_read: (libc)Asynchronous Reads/Writes.
* aio_return64: (libc)Status of AIO Operations.
* aio_return: (libc)Status of AIO Operations.
* aio_suspend64: (libc)Synchronizing AIO Operations.
* aio_suspend: (libc)Synchronizing AIO Operations.
* aio_write64: (libc)Asynchronous Reads/Writes.
* aio_write: (libc)Asynchronous Reads/Writes.
* alarm: (libc)Setting an Alarm.
* alloca: (libc)Variable Size Automatic.
* alphasort64: (libc)Scanning Directory Content.
* alphasort: (libc)Scanning Directory Content.
* argp_error: (libc)Argp Helper Functions.
* argp_failure: (libc)Argp Helper Functions.
* argp_help: (libc)Argp Help.
* argp_parse: (libc)Argp.
* argp_state_help: (libc)Argp Helper Functions.
* argp_usage: (libc)Argp Helper Functions.
* argz_add: (libc)Argz Functions.
* argz_add_sep: (libc)Argz Functions.
* argz_append: (libc)Argz Functions.
* argz_count: (libc)Argz Functions.
* argz_create: (libc)Argz Functions.
* argz_create_sep: (libc)Argz Functions.
* argz_delete: (libc)Argz Functions.
* argz_extract: (libc)Argz Functions.
* argz_insert: (libc)Argz Functions.
* argz_next: (libc)Argz Functions.
* argz_replace: (libc)Argz Functions.
* argz_stringify: (libc)Argz Functions.
* asctime: (libc)Formatting Calendar Time.
* asctime_r: (libc)Formatting Calendar Time.
* asin: (libc)Inverse Trig Functions.
* asinf: (libc)Inverse Trig Functions.
* asinh: (libc)Hyperbolic Functions.
* asinhf: (libc)Hyperbolic Functions.
* asinhl: (libc)Hyperbolic Functions.
* asinl: (libc)Inverse Trig Functions.
* asprintf: (libc)Dynamic Output.
* assert: (libc)Consistency Checking.
* assert_perror: (libc)Consistency Checking.
* atan2: (libc)Inverse Trig Functions.
* atan2f: (libc)Inverse Trig Functions.
* atan2l: (libc)Inverse Trig Functions.
* atan: (libc)Inverse Trig Functions.
* atanf: (libc)Inverse Trig Functions.
* atanh: (libc)Hyperbolic Functions.
* atanhf: (libc)Hyperbolic Functions.
* atanhl: (libc)Hyperbolic Functions.
* atanl: (libc)Inverse Trig Functions.
* atexit: (libc)Cleanups on Exit.
* atof: (libc)Parsing of Floats.
* atoi: (libc)Parsing of Integers.
* atol: (libc)Parsing of Integers.
* atoll: (libc)Parsing of Integers.
* backtrace: (libc)Backtraces.
* backtrace_symbols: (libc)Backtraces.
* backtrace_symbols_fd: (libc)Backtraces.
* basename: (libc)Finding Tokens in a String.
* basename: (libc)Finding Tokens in a String.
* bcmp: (libc)String/Array Comparison.
* bcopy: (libc)Copying and Concatenation.
* bind: (libc)Setting Address.
* bind_textdomain_codeset: (libc)Charset conversion in gettext.
* bindtextdomain: (libc)Locating gettext catalog.
* brk: (libc)Resizing the Data Segment.
* bsearch: (libc)Array Search Function.
* btowc: (libc)Converting a Character.
* bzero: (libc)Copying and Concatenation.
* cabs: (libc)Absolute Value.
* cabsf: (libc)Absolute Value.
* cabsl: (libc)Absolute Value.
* cacos: (libc)Inverse Trig Functions.
* cacosf: (libc)Inverse Trig Functions.
* cacosh: (libc)Hyperbolic Functions.
* cacoshf: (libc)Hyperbolic Functions.
* cacoshl: (libc)Hyperbolic Functions.
* cacosl: (libc)Inverse Trig Functions.
* calloc: (libc)Allocating Cleared Space.
* canonicalize_file_name: (libc)Symbolic Links.
* carg: (libc)Operations on Complex.
* cargf: (libc)Operations on Complex.
* cargl: (libc)Operations on Complex.
* casin: (libc)Inverse Trig Functions.
* casinf: (libc)Inverse Trig Functions.
* casinh: (libc)Hyperbolic Functions.
* casinhf: (libc)Hyperbolic Functions.
* casinhl: (libc)Hyperbolic Functions.
* casinl: (libc)Inverse Trig Functions.
* catan: (libc)Inverse Trig Functions.
* catanf: (libc)Inverse Trig Functions.
* catanh: (libc)Hyperbolic Functions.
* catanhf: (libc)Hyperbolic Functions.
* catanhl: (libc)Hyperbolic Functions.
* catanl: (libc)Inverse Trig Functions.
* catclose: (libc)The catgets Functions.
* catgets: (libc)The catgets Functions.
* catopen: (libc)The catgets Functions.
* cbc_crypt: (libc)DES Encryption.
* cbrt: (libc)Exponents and Logarithms.
* cbrtf: (libc)Exponents and Logarithms.
* cbrtl: (libc)Exponents and Logarithms.
* ccos: (libc)Trig Functions.
* ccosf: (libc)Trig Functions.
* ccosh: (libc)Hyperbolic Functions.
* ccoshf: (libc)Hyperbolic Functions.
* ccoshl: (libc)Hyperbolic Functions.
* ccosl: (libc)Trig Functions.
* ceil: (libc)Rounding Functions.
* ceilf: (libc)Rounding Functions.
* ceill: (libc)Rounding Functions.
* cexp: (libc)Exponents and Logarithms.
* cexpf: (libc)Exponents and Logarithms.
* cexpl: (libc)Exponents and Logarithms.
* cfgetispeed: (libc)Line Speed.
* cfgetospeed: (libc)Line Speed.
* cfmakeraw: (libc)Noncanonical Input.
* cfree: (libc)Freeing after Malloc.
* cfsetispeed: (libc)Line Speed.
* cfsetospeed: (libc)Line Speed.
* cfsetspeed: (libc)Line Speed.
* chdir: (libc)Working Directory.
* chmod: (libc)Setting Permissions.
* chown: (libc)File Owner.
* cimag: (libc)Operations on Complex.
* cimagf: (libc)Operations on Complex.
* cimagl: (libc)Operations on Complex.
* clearenv: (libc)Environment Access.
* clearerr: (libc)Error Recovery.
* clearerr_unlocked: (libc)Error Recovery.
* clock: (libc)CPU Time.
* clog10: (libc)Exponents and Logarithms.
* clog10f: (libc)Exponents and Logarithms.
* clog10l: (libc)Exponents and Logarithms.
* clog: (libc)Exponents and Logarithms.
* clogf: (libc)Exponents and Logarithms.
* clogl: (libc)Exponents and Logarithms.
* close: (libc)Opening and Closing Files.
* closedir: (libc)Reading/Closing Directory.
* closelog: (libc)closelog.
* confstr: (libc)String Parameters.
* conj: (libc)Operations on Complex.
* conjf: (libc)Operations on Complex.
* conjl: (libc)Operations on Complex.
* connect: (libc)Connecting.
* copysign: (libc)FP Bit Twiddling.
* copysignf: (libc)FP Bit Twiddling.
* copysignl: (libc)FP Bit Twiddling.
* cos: (libc)Trig Functions.
* cosf: (libc)Trig Functions.
* cosh: (libc)Hyperbolic Functions.
* coshf: (libc)Hyperbolic Functions.
* coshl: (libc)Hyperbolic Functions.
* cosl: (libc)Trig Functions.
* cpow: (libc)Exponents and Logarithms.
* cpowf: (libc)Exponents and Logarithms.
* cpowl: (libc)Exponents and Logarithms.
* cproj: (libc)Operations on Complex.
* cprojf: (libc)Operations on Complex.
* cprojl: (libc)Operations on Complex.
* creal: (libc)Operations on Complex.
* crealf: (libc)Operations on Complex.
* creall: (libc)Operations on Complex.
* creat64: (libc)Opening and Closing Files.
* creat: (libc)Opening and Closing Files.
* crypt: (libc)crypt.
* crypt_r: (libc)crypt.
* csin: (libc)Trig Functions.
* csinf: (libc)Trig Functions.
* csinh: (libc)Hyperbolic Functions.
* csinhf: (libc)Hyperbolic Functions.
* csinhl: (libc)Hyperbolic Functions.
* csinl: (libc)Trig Functions.
* csqrt: (libc)Exponents and Logarithms.
* csqrtf: (libc)Exponents and Logarithms.
* csqrtl: (libc)Exponents and Logarithms.
* ctan: (libc)Trig Functions.
* ctanf: (libc)Trig Functions.
* ctanh: (libc)Hyperbolic Functions.
* ctanhf: (libc)Hyperbolic Functions.
* ctanhl: (libc)Hyperbolic Functions.
* ctanl: (libc)Trig Functions.
* ctermid: (libc)Identifying the Terminal.
* ctime: (libc)Formatting Calendar Time.
* ctime_r: (libc)Formatting Calendar Time.
* cuserid: (libc)Who Logged In.
* dcgettext: (libc)Translation with gettext.
* dcngettext: (libc)Advanced gettext functions.
* des_setparity: (libc)DES Encryption.
* dgettext: (libc)Translation with gettext.
* difftime: (libc)Elapsed Time.
* dirfd: (libc)Opening a Directory.
* dirname: (libc)Finding Tokens in a String.
* div: (libc)Integer Division.
* dngettext: (libc)Advanced gettext functions.
* drand48: (libc)SVID Random.
* drand48_r: (libc)SVID Random.
* drem: (libc)Remainder Functions.
* dremf: (libc)Remainder Functions.
* dreml: (libc)Remainder Functions.
* dup2: (libc)Duplicating Descriptors.
* dup: (libc)Duplicating Descriptors.
* ecb_crypt: (libc)DES Encryption.
* ecvt: (libc)System V Number Conversion.
* ecvt_r: (libc)System V Number Conversion.
* encrypt: (libc)DES Encryption.
* encrypt_r: (libc)DES Encryption.
* endfsent: (libc)fstab.
* endgrent: (libc)Scanning All Groups.
* endhostent: (libc)Host Names.
* endmntent: (libc)mtab.
* endnetent: (libc)Networks Database.
* endnetgrent: (libc)Lookup Netgroup.
* endprotoent: (libc)Protocols Database.
* endpwent: (libc)Scanning All Users.
* endservent: (libc)Services Database.
* endutent: (libc)Manipulating the Database.
* endutxent: (libc)XPG Functions.
* envz_add: (libc)Envz Functions.
* envz_entry: (libc)Envz Functions.
* envz_get: (libc)Envz Functions.
* envz_merge: (libc)Envz Functions.
* envz_strip: (libc)Envz Functions.
* erand48: (libc)SVID Random.
* erand48_r: (libc)SVID Random.
* erf: (libc)Special Functions.
* erfc: (libc)Special Functions.
* erfcf: (libc)Special Functions.
* erfcl: (libc)Special Functions.
* erff: (libc)Special Functions.
* erfl: (libc)Special Functions.
* err: (libc)Error Messages.
* errno: (libc)Checking for Errors.
* error: (libc)Error Messages.
* error_at_line: (libc)Error Messages.
* errx: (libc)Error Messages.
* execl: (libc)Executing a File.
* execle: (libc)Executing a File.
* execlp: (libc)Executing a File.
* execv: (libc)Executing a File.
* execve: (libc)Executing a File.
* execvp: (libc)Executing a File.
* exit: (libc)Normal Termination.
* exp10: (libc)Exponents and Logarithms.
* exp10f: (libc)Exponents and Logarithms.
* exp10l: (libc)Exponents and Logarithms.
* exp2: (libc)Exponents and Logarithms.
* exp2f: (libc)Exponents and Logarithms.
* exp2l: (libc)Exponents and Logarithms.
* exp: (libc)Exponents and Logarithms.
* expf: (libc)Exponents and Logarithms.
* expl: (libc)Exponents and Logarithms.
* expm1: (libc)Exponents and Logarithms.
* expm1f: (libc)Exponents and Logarithms.
* expm1l: (libc)Exponents and Logarithms.
* fabs: (libc)Absolute Value.
* fabsf: (libc)Absolute Value.
* fabsl: (libc)Absolute Value.
* fchdir: (libc)Working Directory.
* fchmod: (libc)Setting Permissions.
* fchown: (libc)File Owner.
* fclean: (libc)Cleaning Streams.
* fclose: (libc)Closing Streams.
* fcloseall: (libc)Closing Streams.
* fcntl: (libc)Control Operations.
* fcvt: (libc)System V Number Conversion.
* fcvt_r: (libc)System V Number Conversion.
* fdatasync: (libc)Synchronizing I/O.
* fdim: (libc)Misc FP Arithmetic.
* fdimf: (libc)Misc FP Arithmetic.
* fdiml: (libc)Misc FP Arithmetic.
* fdopen: (libc)Descriptors and Streams.
* fdopendir: (libc)Opening a Directory.
* feclearexcept: (libc)Status bit operations.
* fedisableexcept: (libc)Control Functions.
* feenableexcept: (libc)Control Functions.
* fegetenv: (libc)Control Functions.
* fegetexcept: (libc)Control Functions.
* fegetexceptflag: (libc)Status bit operations.
* fegetround: (libc)Rounding.
* feholdexcept: (libc)Control Functions.
* feof: (libc)EOF and Errors.
* feof_unlocked: (libc)EOF and Errors.
* feraiseexcept: (libc)Status bit operations.
* ferror: (libc)EOF and Errors.
* ferror_unlocked: (libc)EOF and Errors.
* fesetenv: (libc)Control Functions.
* fesetexceptflag: (libc)Status bit operations.
* fesetround: (libc)Rounding.
* fetestexcept: (libc)Status bit operations.
* feupdateenv: (libc)Control Functions.
* fflush: (libc)Flushing Buffers.
* fflush_unlocked: (libc)Flushing Buffers.
* fgetc: (libc)Character Input.
* fgetc_unlocked: (libc)Character Input.
* fgetgrent: (libc)Scanning All Groups.
* fgetgrent_r: (libc)Scanning All Groups.
* fgetpos64: (libc)Portable Positioning.
* fgetpos: (libc)Portable Positioning.
* fgetpwent: (libc)Scanning All Users.
* fgetpwent_r: (libc)Scanning All Users.
* fgets: (libc)Line Input.
* fgets_unlocked: (libc)Line Input.
* fgetwc: (libc)Character Input.
* fgetwc_unlocked: (libc)Character Input.
* fgetws: (libc)Line Input.
* fgetws_unlocked: (libc)Line Input.
* fileno: (libc)Descriptors and Streams.
* fileno_unlocked: (libc)Descriptors and Streams.
* finite: (libc)Floating Point Classes.
* finitef: (libc)Floating Point Classes.
* finitel: (libc)Floating Point Classes.
* flockfile: (libc)Streams and Threads.
* floor: (libc)Rounding Functions.
* floorf: (libc)Rounding Functions.
* floorl: (libc)Rounding Functions.
* fma: (libc)Misc FP Arithmetic.
* fmaf: (libc)Misc FP Arithmetic.
* fmal: (libc)Misc FP Arithmetic.
* fmax: (libc)Misc FP Arithmetic.
* fmaxf: (libc)Misc FP Arithmetic.
* fmaxl: (libc)Misc FP Arithmetic.
* fmemopen: (libc)String Streams.
* fmin: (libc)Misc FP Arithmetic.
* fminf: (libc)Misc FP Arithmetic.
* fminl: (libc)Misc FP Arithmetic.
* fmod: (libc)Remainder Functions.
* fmodf: (libc)Remainder Functions.
* fmodl: (libc)Remainder Functions.
* fmtmsg: (libc)Printing Formatted Messages.
* fnmatch: (libc)Wildcard Matching.
* fopen64: (libc)Opening Streams.
* fopen: (libc)Opening Streams.
* fopencookie: (libc)Streams and Cookies.
* fork: (libc)Creating a Process.
* forkpty: (libc)Pseudo-Terminal Pairs.
* fpathconf: (libc)Pathconf.
* fpclassify: (libc)Floating Point Classes.
* fprintf: (libc)Formatted Output Functions.
* fputc: (libc)Simple Output.
* fputc_unlocked: (libc)Simple Output.
* fputs: (libc)Simple Output.
* fputs_unlocked: (libc)Simple Output.
* fputwc: (libc)Simple Output.
* fputwc_unlocked: (libc)Simple Output.
* fputws: (libc)Simple Output.
* fputws_unlocked: (libc)Simple Output.
* fread: (libc)Block Input/Output.
* fread_unlocked: (libc)Block Input/Output.
* free: (libc)Freeing after Malloc.
* freopen64: (libc)Opening Streams.
* freopen: (libc)Opening Streams.
* frexp: (libc)Normalization Functions.
* frexpf: (libc)Normalization Functions.
* frexpl: (libc)Normalization Functions.
* fscanf: (libc)Formatted Input Functions.
* fseek: (libc)File Positioning.
* fseeko64: (libc)File Positioning.
* fseeko: (libc)File Positioning.
* fsetpos64: (libc)Portable Positioning.
* fsetpos: (libc)Portable Positioning.
* fstat64: (libc)Reading Attributes.
* fstat: (libc)Reading Attributes.
* fsync: (libc)Synchronizing I/O.
* ftell: (libc)File Positioning.
* ftello64: (libc)File Positioning.
* ftello: (libc)File Positioning.
* ftruncate64: (libc)File Size.
* ftruncate: (libc)File Size.
* ftrylockfile: (libc)Streams and Threads.
* ftw64: (libc)Working with Directory Trees.
* ftw: (libc)Working with Directory Trees.
* funlockfile: (libc)Streams and Threads.
* futimes: (libc)File Times.
* fwide: (libc)Streams and I18N.
* fwprintf: (libc)Formatted Output Functions.
* fwrite: (libc)Block Input/Output.
* fwrite_unlocked: (libc)Block Input/Output.
* fwscanf: (libc)Formatted Input Functions.
* gamma: (libc)Special Functions.
* gammaf: (libc)Special Functions.
* gammal: (libc)Special Functions.
* gcvt: (libc)System V Number Conversion.
* get_avphys_pages: (libc)Query Memory Parameters.
* get_current_dir_name: (libc)Working Directory.
* get_nprocs: (libc)Processor Resources.
* get_nprocs_conf: (libc)Processor Resources.
* get_phys_pages: (libc)Query Memory Parameters.
* getc: (libc)Character Input.
* getc_unlocked: (libc)Character Input.
* getchar: (libc)Character Input.
* getchar_unlocked: (libc)Character Input.
* getcontext: (libc)System V contexts.
* getcwd: (libc)Working Directory.
* getdate: (libc)General Time String Parsing.
* getdate_r: (libc)General Time String Parsing.
* getdelim: (libc)Line Input.
* getdomainnname: (libc)Host Identification.
* getegid: (libc)Reading Persona.
* getenv: (libc)Environment Access.
* geteuid: (libc)Reading Persona.
* getfsent: (libc)fstab.
* getfsfile: (libc)fstab.
* getfsspec: (libc)fstab.
* getgid: (libc)Reading Persona.
* getgrent: (libc)Scanning All Groups.
* getgrent_r: (libc)Scanning All Groups.
* getgrgid: (libc)Lookup Group.
* getgrgid_r: (libc)Lookup Group.
* getgrnam: (libc)Lookup Group.
* getgrnam_r: (libc)Lookup Group.
* getgrouplist: (libc)Setting Groups.
* getgroups: (libc)Reading Persona.
* gethostbyaddr: (libc)Host Names.
* gethostbyaddr_r: (libc)Host Names.
* gethostbyname2: (libc)Host Names.
* gethostbyname2_r: (libc)Host Names.
* gethostbyname: (libc)Host Names.
* gethostbyname_r: (libc)Host Names.
* gethostent: (libc)Host Names.
* gethostid: (libc)Host Identification.
* gethostname: (libc)Host Identification.
* getitimer: (libc)Setting an Alarm.
* getline: (libc)Line Input.
* getloadavg: (libc)Processor Resources.
* getlogin: (libc)Who Logged In.
* getmntent: (libc)mtab.
* getmntent_r: (libc)mtab.
* getnetbyaddr: (libc)Networks Database.
* getnetbyname: (libc)Networks Database.
* getnetent: (libc)Networks Database.
* getnetgrent: (libc)Lookup Netgroup.
* getnetgrent_r: (libc)Lookup Netgroup.
* getopt: (libc)Using Getopt.
* getopt_long: (libc)Getopt Long Options.
* getopt_long_only: (libc)Getopt Long Options.
* getpagesize: (libc)Query Memory Parameters.
* getpass: (libc)getpass.
* getpeername: (libc)Who is Connected.
* getpgid: (libc)Process Group Functions.
* getpgrp: (libc)Process Group Functions.
* getpgrp: (libc)Process Group Functions.
* getpid: (libc)Process Identification.
* getppid: (libc)Process Identification.
* getpriority: (libc)Traditional Scheduling Functions.
* getprotobyname: (libc)Protocols Database.
* getprotobynumber: (libc)Protocols Database.
* getprotoent: (libc)Protocols Database.
* getpt: (libc)Allocation.
* getpwent: (libc)Scanning All Users.
* getpwent_r: (libc)Scanning All Users.
* getpwnam: (libc)Lookup User.
* getpwnam_r: (libc)Lookup User.
* getpwuid: (libc)Lookup User.
* getpwuid_r: (libc)Lookup User.
* getrlimit64: (libc)Limits on Resources.
* getrlimit: (libc)Limits on Resources.
* getrusage: (libc)Resource Usage.
* gets: (libc)Line Input.
* getservbyname: (libc)Services Database.
* getservbyport: (libc)Services Database.
* getservent: (libc)Services Database.
* getsid: (libc)Process Group Functions.
* getsockname: (libc)Reading Address.
* getsockopt: (libc)Socket Option Functions.
* getsubopt: (libc)Suboptions.
* gettext: (libc)Translation with gettext.
* gettimeofday: (libc)High-Resolution Calendar.
* getuid: (libc)Reading Persona.
* getumask: (libc)Setting Permissions.
* getutent: (libc)Manipulating the Database.
* getutent_r: (libc)Manipulating the Database.
* getutid: (libc)Manipulating the Database.
* getutid_r: (libc)Manipulating the Database.
* getutline: (libc)Manipulating the Database.
* getutline_r: (libc)Manipulating the Database.
* getutmp: (libc)XPG Functions.
* getutmpx: (libc)XPG Functions.
* getutxent: (libc)XPG Functions.
* getutxid: (libc)XPG Functions.
* getutxline: (libc)XPG Functions.
* getw: (libc)Character Input.
* getwc: (libc)Character Input.
* getwc_unlocked: (libc)Character Input.
* getwchar: (libc)Character Input.
* getwchar_unlocked: (libc)Character Input.
* getwd: (libc)Working Directory.
* glob64: (libc)Calling Glob.
* glob: (libc)Calling Glob.
* globfree64: (libc)More Flags for Globbing.
* globfree: (libc)More Flags for Globbing.
* gmtime: (libc)Broken-down Time.
* gmtime_r: (libc)Broken-down Time.
* grantpt: (libc)Allocation.
* gsignal: (libc)Signaling Yourself.
* gtty: (libc)BSD Terminal Modes.
* hasmntopt: (libc)mtab.
* hcreate: (libc)Hash Search Function.
* hcreate_r: (libc)Hash Search Function.
* hdestroy: (libc)Hash Search Function.
* hdestroy_r: (libc)Hash Search Function.
* hsearch: (libc)Hash Search Function.
* hsearch_r: (libc)Hash Search Function.
* htonl: (libc)Byte Order.
* htons: (libc)Byte Order.
* hypot: (libc)Exponents and Logarithms.
* hypotf: (libc)Exponents and Logarithms.
* hypotl: (libc)Exponents and Logarithms.
* iconv: (libc)Generic Conversion Interface.
* iconv_close: (libc)Generic Conversion Interface.
* iconv_open: (libc)Generic Conversion Interface.
* if_freenameindex: (libc)Interface Naming.
* if_indextoname: (libc)Interface Naming.
* if_nameindex: (libc)Interface Naming.
* if_nametoindex: (libc)Interface Naming.
* ilogb: (libc)Exponents and Logarithms.
* ilogbf: (libc)Exponents and Logarithms.
* ilogbl: (libc)Exponents and Logarithms.
* imaxabs: (libc)Absolute Value.
* imaxdiv: (libc)Integer Division.
* in6addr_any: (libc)Host Address Data Type.
* in6addr_loopback: (libc)Host Address Data Type.
* index: (libc)Search Functions.
* inet_addr: (libc)Host Address Functions.
* inet_aton: (libc)Host Address Functions.
* inet_lnaof: (libc)Host Address Functions.
* inet_makeaddr: (libc)Host Address Functions.
* inet_netof: (libc)Host Address Functions.
* inet_network: (libc)Host Address Functions.
* inet_ntoa: (libc)Host Address Functions.
* inet_ntop: (libc)Host Address Functions.
* inet_pton: (libc)Host Address Functions.
* initgroups: (libc)Setting Groups.
* initstate: (libc)BSD Random.
* initstate_r: (libc)BSD Random.
* innetgr: (libc)Netgroup Membership.
* int: (libc)Random Access Directory.
* ioctl: (libc)IOCTLs.
* isalnum: (libc)Classification of Characters.
* isalpha: (libc)Classification of Characters.
* isascii: (libc)Classification of Characters.
* isatty: (libc)Is It a Terminal.
* isblank: (libc)Classification of Characters.
* iscntrl: (libc)Classification of Characters.
* isdigit: (libc)Classification of Characters.
* isfinite: (libc)Floating Point Classes.
* isgraph: (libc)Classification of Characters.
* isgreater: (libc)FP Comparison Functions.
* isgreaterequal: (libc)FP Comparison Functions.
* isinf: (libc)Floating Point Classes.
* isinff: (libc)Floating Point Classes.
* isinfl: (libc)Floating Point Classes.
* isless: (libc)FP Comparison Functions.
* islessequal: (libc)FP Comparison Functions.
* islessgreater: (libc)FP Comparison Functions.
* islower: (libc)Classification of Characters.
* isnan: (libc)Floating Point Classes.
* isnan: (libc)Floating Point Classes.
* isnanf: (libc)Floating Point Classes.
* isnanl: (libc)Floating Point Classes.
* isnormal: (libc)Floating Point Classes.
* isprint: (libc)Classification of Characters.
* ispunct: (libc)Classification of Characters.
* isspace: (libc)Classification of Characters.
* isunordered: (libc)FP Comparison Functions.
* isupper: (libc)Classification of Characters.
* iswalnum: (libc)Classification of Wide Characters.
* iswalpha: (libc)Classification of Wide Characters.
* iswblank: (libc)Classification of Wide Characters.
* iswcntrl: (libc)Classification of Wide Characters.
* iswctype: (libc)Classification of Wide Characters.
* iswdigit: (libc)Classification of Wide Characters.
* iswgraph: (libc)Classification of Wide Characters.
* iswlower: (libc)Classification of Wide Characters.
* iswprint: (libc)Classification of Wide Characters.
* iswpunct: (libc)Classification of Wide Characters.
* iswspace: (libc)Classification of Wide Characters.
* iswupper: (libc)Classification of Wide Characters.
* iswxdigit: (libc)Classification of Wide Characters.
* isxdigit: (libc)Classification of Characters.
* j0: (libc)Special Functions.
* j0f: (libc)Special Functions.
* j0l: (libc)Special Functions.
* j1: (libc)Special Functions.
* j1f: (libc)Special Functions.
* j1l: (libc)Special Functions.
* jn: (libc)Special Functions.
* jnf: (libc)Special Functions.
* jnl: (libc)Special Functions.
* jrand48: (libc)SVID Random.
* jrand48_r: (libc)SVID Random.
* kill: (libc)Signaling Another Process.
* killpg: (libc)Signaling Another Process.
* l64a: (libc)Encode Binary Data.
* labs: (libc)Absolute Value.
* lcong48: (libc)SVID Random.
* lcong48_r: (libc)SVID Random.
* ldexp: (libc)Normalization Functions.
* ldexpf: (libc)Normalization Functions.
* ldexpl: (libc)Normalization Functions.
* ldiv: (libc)Integer Division.
* lfind: (libc)Array Search Function.
* lgamma: (libc)Special Functions.
* lgamma_r: (libc)Special Functions.
* lgammaf: (libc)Special Functions.
* lgammaf_r: (libc)Special Functions.
* lgammal: (libc)Special Functions.
* lgammal_r: (libc)Special Functions.
* link: (libc)Hard Links.
* lio_listio64: (libc)Asynchronous Reads/Writes.
* lio_listio: (libc)Asynchronous Reads/Writes.
* listen: (libc)Listening.
* llabs: (libc)Absolute Value.
* lldiv: (libc)Integer Division.
* llrint: (libc)Rounding Functions.
* llrintf: (libc)Rounding Functions.
* llrintl: (libc)Rounding Functions.
* llround: (libc)Rounding Functions.
* llroundf: (libc)Rounding Functions.
* llroundl: (libc)Rounding Functions.
* localeconv: (libc)The Lame Way to Locale Data.
* localtime: (libc)Broken-down Time.
* localtime_r: (libc)Broken-down Time.
* log10: (libc)Exponents and Logarithms.
* log10f: (libc)Exponents and Logarithms.
* log10l: (libc)Exponents and Logarithms.
* log1p: (libc)Exponents and Logarithms.
* log1pf: (libc)Exponents and Logarithms.
* log1pl: (libc)Exponents and Logarithms.
* log2: (libc)Exponents and Logarithms.
* log2f: (libc)Exponents and Logarithms.
* log2l: (libc)Exponents and Logarithms.
* log: (libc)Exponents and Logarithms.
* logb: (libc)Exponents and Logarithms.
* logbf: (libc)Exponents and Logarithms.
* logbl: (libc)Exponents and Logarithms.
* logf: (libc)Exponents and Logarithms.
* login: (libc)Logging In and Out.
* login_tty: (libc)Logging In and Out.
* logl: (libc)Exponents and Logarithms.
* logout: (libc)Logging In and Out.
* logwtmp: (libc)Logging In and Out.
* longjmp: (libc)Non-Local Details.
* lrand48: (libc)SVID Random.
* lrand48_r: (libc)SVID Random.
* lrint: (libc)Rounding Functions.
* lrintf: (libc)Rounding Functions.
* lrintl: (libc)Rounding Functions.
* lround: (libc)Rounding Functions.
* lroundf: (libc)Rounding Functions.
* lroundl: (libc)Rounding Functions.
* lsearch: (libc)Array Search Function.
* lseek64: (libc)File Position Primitive.
* lseek: (libc)File Position Primitive.
* lstat64: (libc)Reading Attributes.
* lstat: (libc)Reading Attributes.
* lutimes: (libc)File Times.
* madvise: (libc)Memory-mapped I/O.
* makecontext: (libc)System V contexts.
* mallinfo: (libc)Statistics of Malloc.
* malloc: (libc)Basic Allocation.
* mallopt: (libc)Malloc Tunable Parameters.
* mblen: (libc)Non-reentrant Character Conversion.
* mbrlen: (libc)Converting a Character.
* mbrtowc: (libc)Converting a Character.
* mbsinit: (libc)Keeping the state.
* mbsnrtowcs: (libc)Converting Strings.
* mbsrtowcs: (libc)Converting Strings.
* mbstowcs: (libc)Non-reentrant String Conversion.
* mbtowc: (libc)Non-reentrant Character Conversion.
* mcheck: (libc)Heap Consistency Checking.
* memalign: (libc)Aligned Memory Blocks.
* memccpy: (libc)Copying and Concatenation.
* memchr: (libc)Search Functions.
* memcmp: (libc)String/Array Comparison.
* memcpy: (libc)Copying and Concatenation.
* memfrob: (libc)Trivial Encryption.
* memmem: (libc)Search Functions.
* memmove: (libc)Copying and Concatenation.
* mempcpy: (libc)Copying and Concatenation.
* memrchr: (libc)Search Functions.
* memset: (libc)Copying and Concatenation.
* mkdir: (libc)Creating Directories.
* mkdtemp: (libc)Temporary Files.
* mkfifo: (libc)FIFO Special Files.
* mknod: (libc)Making Special Files.
* mkstemp: (libc)Temporary Files.
* mktemp: (libc)Temporary Files.
* mktime: (libc)Broken-down Time.
* mlock: (libc)Page Lock Functions.
* mlockall: (libc)Page Lock Functions.
* mmap64: (libc)Memory-mapped I/O.
* mmap: (libc)Memory-mapped I/O.
* modf: (libc)Rounding Functions.
* modff: (libc)Rounding Functions.
* modfl: (libc)Rounding Functions.
* mount: (libc)Mount-Unmount-Remount.
* mprobe: (libc)Heap Consistency Checking.
* mrand48: (libc)SVID Random.
* mrand48_r: (libc)SVID Random.
* mremap: (libc)Memory-mapped I/O.
* msync: (libc)Memory-mapped I/O.
* mtrace: (libc)Tracing malloc.
* munlock: (libc)Page Lock Functions.
* munlockall: (libc)Page Lock Functions.
* munmap: (libc)Memory-mapped I/O.
* muntrace: (libc)Tracing malloc.
* nan: (libc)FP Bit Twiddling.
* nanf: (libc)FP Bit Twiddling.
* nanl: (libc)FP Bit Twiddling.
* nanosleep: (libc)Sleeping.
* nearbyint: (libc)Rounding Functions.
* nearbyintf: (libc)Rounding Functions.
* nearbyintl: (libc)Rounding Functions.
* nextafter: (libc)FP Bit Twiddling.
* nextafterf: (libc)FP Bit Twiddling.
* nextafterl: (libc)FP Bit Twiddling.
* nexttoward: (libc)FP Bit Twiddling.
* nexttowardf: (libc)FP Bit Twiddling.
* nexttowardl: (libc)FP Bit Twiddling.
* nftw64: (libc)Working with Directory Trees.
* nftw: (libc)Working with Directory Trees.
* ngettext: (libc)Advanced gettext functions.
* nice: (libc)Traditional Scheduling Functions.
* nl_langinfo: (libc)The Elegant and Fast Way.
* nrand48: (libc)SVID Random.
* nrand48_r: (libc)SVID Random.
* ntohl: (libc)Byte Order.
* ntohs: (libc)Byte Order.
* ntp_adjtime: (libc)High Accuracy Clock.
* ntp_gettime: (libc)High Accuracy Clock.
* obstack_1grow: (libc)Growing Objects.
* obstack_1grow_fast: (libc)Extra Fast Growing.
* obstack_alignment_mask: (libc)Obstacks Data Alignment.
* obstack_alloc: (libc)Allocation in an Obstack.
* obstack_base: (libc)Status of an Obstack.
* obstack_blank: (libc)Growing Objects.
* obstack_blank_fast: (libc)Extra Fast Growing.
* obstack_chunk_size: (libc)Obstack Chunks.
* obstack_copy0: (libc)Allocation in an Obstack.
* obstack_copy: (libc)Allocation in an Obstack.
* obstack_finish: (libc)Growing Objects.
* obstack_free: (libc)Freeing Obstack Objects.
* obstack_grow0: (libc)Growing Objects.
* obstack_grow: (libc)Growing Objects.
* obstack_init: (libc)Preparing for Obstacks.
* obstack_int_grow: (libc)Growing Objects.
* obstack_int_grow_fast: (libc)Extra Fast Growing.
* obstack_next_free: (libc)Status of an Obstack.
* obstack_object_size: (libc)Growing Objects.
* obstack_object_size: (libc)Status of an Obstack.
* obstack_printf: (libc)Dynamic Output.
* obstack_ptr_grow: (libc)Growing Objects.
* obstack_ptr_grow_fast: (libc)Extra Fast Growing.
* obstack_room: (libc)Extra Fast Growing.
* obstack_vprintf: (libc)Variable Arguments Output.
* offsetof: (libc)Structure Measurement.
* on_exit: (libc)Cleanups on Exit.
* open64: (libc)Opening and Closing Files.
* open: (libc)Opening and Closing Files.
* open_memstream: (libc)String Streams.
* open_obstack_stream: (libc)Obstack Streams.
* opendir: (libc)Opening a Directory.
* openlog: (libc)openlog.
* openpty: (libc)Pseudo-Terminal Pairs.
* parse_printf_format: (libc)Parsing a Template String.
* pathconf: (libc)Pathconf.
* pause: (libc)Using Pause.
* pclose: (libc)Pipe to a Subprocess.
* perror: (libc)Error Messages.
* pipe: (libc)Creating a Pipe.
* popen: (libc)Pipe to a Subprocess.
* posix_memalign: (libc)Aligned Memory Blocks.
* pow10: (libc)Exponents and Logarithms.
* pow10f: (libc)Exponents and Logarithms.
* pow10l: (libc)Exponents and Logarithms.
* pow: (libc)Exponents and Logarithms.
* powf: (libc)Exponents and Logarithms.
* powl: (libc)Exponents and Logarithms.
* pread64: (libc)I/O Primitives.
* pread: (libc)I/O Primitives.
* printf: (libc)Formatted Output Functions.
* printf_size: (libc)Predefined Printf Handlers.
* printf_size_info: (libc)Predefined Printf Handlers.
* psignal: (libc)Signal Messages.
* ptsname: (libc)Allocation.
* ptsname_r: (libc)Allocation.
* putc: (libc)Simple Output.
* putc_unlocked: (libc)Simple Output.
* putchar: (libc)Simple Output.
* putchar_unlocked: (libc)Simple Output.
* putenv: (libc)Environment Access.
* putpwent: (libc)Writing a User Entry.
* puts: (libc)Simple Output.
* pututline: (libc)Manipulating the Database.
* pututxline: (libc)XPG Functions.
* putw: (libc)Simple Output.
* putwc: (libc)Simple Output.
* putwc_unlocked: (libc)Simple Output.
* putwchar: (libc)Simple Output.
* putwchar_unlocked: (libc)Simple Output.
* pwrite64: (libc)I/O Primitives.
* pwrite: (libc)I/O Primitives.
* qecvt: (libc)System V Number Conversion.
* qecvt_r: (libc)System V Number Conversion.
* qfcvt: (libc)System V Number Conversion.
* qfcvt_r: (libc)System V Number Conversion.
* qgcvt: (libc)System V Number Conversion.
* qsort: (libc)Array Sort Function.
* raise: (libc)Signaling Yourself.
* rand: (libc)ISO Random.
* rand_r: (libc)ISO Random.
* random: (libc)BSD Random.
* random_r: (libc)BSD Random.
* rawmemchr: (libc)Search Functions.
* read: (libc)I/O Primitives.
* readdir64: (libc)Reading/Closing Directory.
* readdir64_r: (libc)Reading/Closing Directory.
* readdir: (libc)Reading/Closing Directory.
* readdir_r: (libc)Reading/Closing Directory.
* readlink: (libc)Symbolic Links.
* readv: (libc)Scatter-Gather.
* realloc: (libc)Changing Block Size.
* realpath: (libc)Symbolic Links.
* recv: (libc)Receiving Data.
* recvfrom: (libc)Receiving Datagrams.
* recvmsg: (libc)Receiving Datagrams.
* regcomp: (libc)POSIX Regexp Compilation.
* regerror: (libc)Regexp Cleanup.
* regexec: (libc)Matching POSIX Regexps.
* regfree: (libc)Regexp Cleanup.
* register_printf_function: (libc)Registering New Conversions.
* remainder: (libc)Remainder Functions.
* remainderf: (libc)Remainder Functions.
* remainderl: (libc)Remainder Functions.
* remove: (libc)Deleting Files.
* rename: (libc)Renaming Files.
* rewind: (libc)File Positioning.
* rewinddir: (libc)Random Access Directory.
* rindex: (libc)Search Functions.
* rint: (libc)Rounding Functions.
* rintf: (libc)Rounding Functions.
* rintl: (libc)Rounding Functions.
* rmdir: (libc)Deleting Files.
* round: (libc)Rounding Functions.
* roundf: (libc)Rounding Functions.
* roundl: (libc)Rounding Functions.
* rpmatch: (libc)Yes-or-No Questions.
* sbrk: (libc)Resizing the Data Segment.
* scalb: (libc)Normalization Functions.
* scalbf: (libc)Normalization Functions.
* scalbl: (libc)Normalization Functions.
* scalbln: (libc)Normalization Functions.
* scalblnf: (libc)Normalization Functions.
* scalblnl: (libc)Normalization Functions.
* scalbn: (libc)Normalization Functions.
* scalbnf: (libc)Normalization Functions.
* scalbnl: (libc)Normalization Functions.
* scandir64: (libc)Scanning Directory Content.
* scandir: (libc)Scanning Directory Content.
* scanf: (libc)Formatted Input Functions.
* sched_get_priority_max: (libc)Basic Scheduling Functions.
* sched_get_priority_min: (libc)Basic Scheduling Functions.
* sched_getaffinity: (libc)CPU Affinity.
* sched_getparam: (libc)Basic Scheduling Functions.
* sched_getscheduler: (libc)Basic Scheduling Functions.
* sched_rr_get_interval: (libc)Basic Scheduling Functions.
* sched_setaffinity: (libc)CPU Affinity.
* sched_setparam: (libc)Basic Scheduling Functions.
* sched_setscheduler: (libc)Basic Scheduling Functions.
* sched_yield: (libc)Basic Scheduling Functions.
* seed48: (libc)SVID Random.
* seed48_r: (libc)SVID Random.
* seekdir: (libc)Random Access Directory.
* select: (libc)Waiting for I/O.
* send: (libc)Sending Data.
* sendmsg: (libc)Receiving Datagrams.
* sendto: (libc)Sending Datagrams.
* setbuf: (libc)Controlling Buffering.
* setbuffer: (libc)Controlling Buffering.
* setcontext: (libc)System V contexts.
* setdomainname: (libc)Host Identification.
* setegid: (libc)Setting Groups.
* setenv: (libc)Environment Access.
* seteuid: (libc)Setting User ID.
* setfsent: (libc)fstab.
* setgid: (libc)Setting Groups.
* setgrent: (libc)Scanning All Groups.
* setgroups: (libc)Setting Groups.
* sethostent: (libc)Host Names.
* sethostid: (libc)Host Identification.
* sethostname: (libc)Host Identification.
* setitimer: (libc)Setting an Alarm.
* setjmp: (libc)Non-Local Details.
* setkey: (libc)DES Encryption.
* setkey_r: (libc)DES Encryption.
* setlinebuf: (libc)Controlling Buffering.
* setlocale: (libc)Setting the Locale.
* setlogmask: (libc)setlogmask.
* setmntent: (libc)mtab.
* setnetent: (libc)Networks Database.
* setnetgrent: (libc)Lookup Netgroup.
* setpgid: (libc)Process Group Functions.
* setpgrp: (libc)Process Group Functions.
* setpriority: (libc)Traditional Scheduling Functions.
* setprotoent: (libc)Protocols Database.
* setpwent: (libc)Scanning All Users.
* setregid: (libc)Setting Groups.
* setreuid: (libc)Setting User ID.
* setrlimit64: (libc)Limits on Resources.
* setrlimit: (libc)Limits on Resources.
* setservent: (libc)Services Database.
* setsid: (libc)Process Group Functions.
* setsockopt: (libc)Socket Option Functions.
* setstate: (libc)BSD Random.
* setstate_r: (libc)BSD Random.
* settimeofday: (libc)High-Resolution Calendar.
* setuid: (libc)Setting User ID.
* setutent: (libc)Manipulating the Database.
* setutxent: (libc)XPG Functions.
* setvbuf: (libc)Controlling Buffering.
* shutdown: (libc)Closing a Socket.
* sigaction: (libc)Advanced Signal Handling.
* sigaddset: (libc)Signal Sets.
* sigaltstack: (libc)Signal Stack.
* sigblock: (libc)Blocking in BSD.
* sigdelset: (libc)Signal Sets.
* sigemptyset: (libc)Signal Sets.
* sigfillset: (libc)Signal Sets.
* siginterrupt: (libc)BSD Handler.
* sigismember: (libc)Signal Sets.
* siglongjmp: (libc)Non-Local Exits and Signals.
* sigmask: (libc)Blocking in BSD.
* signal: (libc)Basic Signal Handling.
* signbit: (libc)FP Bit Twiddling.
* significand: (libc)Normalization Functions.
* significandf: (libc)Normalization Functions.
* significandl: (libc)Normalization Functions.
* sigpause: (libc)Blocking in BSD.
* sigpending: (libc)Checking for Pending Signals.
* sigprocmask: (libc)Process Signal Mask.
* sigsetjmp: (libc)Non-Local Exits and Signals.
* sigsetmask: (libc)Blocking in BSD.
* sigstack: (libc)Signal Stack.
* sigsuspend: (libc)Sigsuspend.
* sigvec: (libc)BSD Handler.
* sin: (libc)Trig Functions.
* sincos: (libc)Trig Functions.
* sincosf: (libc)Trig Functions.
* sincosl: (libc)Trig Functions.
* sinf: (libc)Trig Functions.
* sinh: (libc)Hyperbolic Functions.
* sinhf: (libc)Hyperbolic Functions.
* sinhl: (libc)Hyperbolic Functions.
* sinl: (libc)Trig Functions.
* sleep: (libc)Sleeping.
* snprintf: (libc)Formatted Output Functions.
* socket: (libc)Creating a Socket.
* socketpair: (libc)Socket Pairs.
* sprintf: (libc)Formatted Output Functions.
* sqrt: (libc)Exponents and Logarithms.
* sqrtf: (libc)Exponents and Logarithms.
* sqrtl: (libc)Exponents and Logarithms.
* srand48: (libc)SVID Random.
* srand48_r: (libc)SVID Random.
* srand: (libc)ISO Random.
* srandom: (libc)BSD Random.
* srandom_r: (libc)BSD Random.
* sscanf: (libc)Formatted Input Functions.
* ssignal: (libc)Basic Signal Handling.
* stat64: (libc)Reading Attributes.
* stat: (libc)Reading Attributes.
* stime: (libc)Simple Calendar Time.
* stpcpy: (libc)Copying and Concatenation.
* stpncpy: (libc)Copying and Concatenation.
* strcasecmp: (libc)String/Array Comparison.
* strcasestr: (libc)Search Functions.
* strcat: (libc)Copying and Concatenation.
* strchr: (libc)Search Functions.
* strchrnul: (libc)Search Functions.
* strcmp: (libc)String/Array Comparison.
* strcoll: (libc)Collation Functions.
* strcpy: (libc)Copying and Concatenation.
* strcspn: (libc)Search Functions.
* strdup: (libc)Copying and Concatenation.
* strdupa: (libc)Copying and Concatenation.
* strerror: (libc)Error Messages.
* strerror_r: (libc)Error Messages.
* strfmon: (libc)Formatting Numbers.
* strfry: (libc)strfry.
* strftime: (libc)Formatting Calendar Time.
* strlen: (libc)String Length.
* strncasecmp: (libc)String/Array Comparison.
* strncat: (libc)Copying and Concatenation.
* strncmp: (libc)String/Array Comparison.
* strncpy: (libc)Copying and Concatenation.
* strndup: (libc)Copying and Concatenation.
* strndupa: (libc)Copying and Concatenation.
* strnlen: (libc)String Length.
* strpbrk: (libc)Search Functions.
* strptime: (libc)Low-Level Time String Parsing.
* strrchr: (libc)Search Functions.
* strsep: (libc)Finding Tokens in a String.
* strsignal: (libc)Signal Messages.
* strspn: (libc)Search Functions.
* strstr: (libc)Search Functions.
* strtod: (libc)Parsing of Floats.
* strtof: (libc)Parsing of Floats.
* strtoimax: (libc)Parsing of Integers.
* strtok: (libc)Finding Tokens in a String.
* strtok_r: (libc)Finding Tokens in a String.
* strtol: (libc)Parsing of Integers.
* strtold: (libc)Parsing of Floats.
* strtoll: (libc)Parsing of Integers.
* strtoq: (libc)Parsing of Integers.
* strtoul: (libc)Parsing of Integers.
* strtoull: (libc)Parsing of Integers.
* strtoumax: (libc)Parsing of Integers.
* strtouq: (libc)Parsing of Integers.
* strverscmp: (libc)String/Array Comparison.
* strxfrm: (libc)Collation Functions.
* stty: (libc)BSD Terminal Modes.
* swapcontext: (libc)System V contexts.
* swprintf: (libc)Formatted Output Functions.
* swscanf: (libc)Formatted Input Functions.
* symlink: (libc)Symbolic Links.
* sync: (libc)Synchronizing I/O.
* syscall: (libc)System Calls.
* sysconf: (libc)Sysconf Definition.
* sysctl: (libc)System Parameters.
* syslog: (libc)syslog; vsyslog.
* system: (libc)Running a Command.
* sysv_signal: (libc)Basic Signal Handling.
* tan: (libc)Trig Functions.
* tanf: (libc)Trig Functions.
* tanh: (libc)Hyperbolic Functions.
* tanhf: (libc)Hyperbolic Functions.
* tanhl: (libc)Hyperbolic Functions.
* tanl: (libc)Trig Functions.
* tcdrain: (libc)Line Control.
* tcflow: (libc)Line Control.
* tcflush: (libc)Line Control.
* tcgetattr: (libc)Mode Functions.
* tcgetpgrp: (libc)Terminal Access Functions.
* tcgetsid: (libc)Terminal Access Functions.
* tcsendbreak: (libc)Line Control.
* tcsetattr: (libc)Mode Functions.
* tcsetpgrp: (libc)Terminal Access Functions.
* tdelete: (libc)Tree Search Function.
* tdestroy: (libc)Tree Search Function.
* tempnam: (libc)Temporary Files.
* textdomain: (libc)Locating gettext catalog.
* tfind: (libc)Tree Search Function.
* tgamma: (libc)Special Functions.
* tgammaf: (libc)Special Functions.
* tgammal: (libc)Special Functions.
* time: (libc)Simple Calendar Time.
* timegm: (libc)Broken-down Time.
* timelocal: (libc)Broken-down Time.
* times: (libc)Processor Time.
* tmpfile64: (libc)Temporary Files.
* tmpfile: (libc)Temporary Files.
* tmpnam: (libc)Temporary Files.
* tmpnam_r: (libc)Temporary Files.
* toascii: (libc)Case Conversion.
* tolower: (libc)Case Conversion.
* toupper: (libc)Case Conversion.
* towctrans: (libc)Wide Character Case Conversion.
* towlower: (libc)Wide Character Case Conversion.
* towupper: (libc)Wide Character Case Conversion.
* trunc: (libc)Rounding Functions.
* truncate64: (libc)File Size.
* truncate: (libc)File Size.
* truncf: (libc)Rounding Functions.
* truncl: (libc)Rounding Functions.
* tsearch: (libc)Tree Search Function.
* ttyname: (libc)Is It a Terminal.
* ttyname_r: (libc)Is It a Terminal.
* twalk: (libc)Tree Search Function.
* tzset: (libc)Time Zone Functions.
* ulimit: (libc)Limits on Resources.
* umask: (libc)Setting Permissions.
* umount2: (libc)Mount-Unmount-Remount.
* umount: (libc)Mount-Unmount-Remount.
* uname: (libc)Platform Type.
* ungetc: (libc)How Unread.
* ungetwc: (libc)How Unread.
* unlink: (libc)Deleting Files.
* unlockpt: (libc)Allocation.
* unsetenv: (libc)Environment Access.
* updwtmp: (libc)Manipulating the Database.
* utime: (libc)File Times.
* utimes: (libc)File Times.
* utmpname: (libc)Manipulating the Database.
* utmpxname: (libc)XPG Functions.
* va_arg: (libc)Argument Macros.
* va_end: (libc)Argument Macros.
* va_start: (libc)Argument Macros.
* va_start: (libc)Old Varargs.
* valloc: (libc)Aligned Memory Blocks.
* vasprintf: (libc)Variable Arguments Output.
* verr: (libc)Error Messages.
* verrx: (libc)Error Messages.
* versionsort64: (libc)Scanning Directory Content.
* versionsort: (libc)Scanning Directory Content.
* vfork: (libc)Creating a Process.
* vfprintf: (libc)Variable Arguments Output.
* vfscanf: (libc)Variable Arguments Input.
* vfwprintf: (libc)Variable Arguments Output.
* vfwscanf: (libc)Variable Arguments Input.
* vlimit: (libc)Limits on Resources.
* vprintf: (libc)Variable Arguments Output.
* vscanf: (libc)Variable Arguments Input.
* vsnprintf: (libc)Variable Arguments Output.
* vsprintf: (libc)Variable Arguments Output.
* vsscanf: (libc)Variable Arguments Input.
* vswprintf: (libc)Variable Arguments Output.
* vswscanf: (libc)Variable Arguments Input.
* vsyslog: (libc)syslog; vsyslog.
* vtimes: (libc)Resource Usage.
* vwarn: (libc)Error Messages.
* vwarnx: (libc)Error Messages.
* vwprintf: (libc)Variable Arguments Output.
* vwscanf: (libc)Variable Arguments Input.
* wait3: (libc)BSD Wait Functions.
* wait4: (libc)Process Completion.
* wait: (libc)Process Completion.
* waitpid: (libc)Process Completion.
* warn: (libc)Error Messages.
* warnx: (libc)Error Messages.
* wcpcpy: (libc)Copying and Concatenation.
* wcpncpy: (libc)Copying and Concatenation.
* wcrtomb: (libc)Converting a Character.
* wcscasecmp: (libc)String/Array Comparison.
* wcscat: (libc)Copying and Concatenation.
* wcschr: (libc)Search Functions.
* wcschrnul: (libc)Search Functions.
* wcscmp: (libc)String/Array Comparison.
* wcscoll: (libc)Collation Functions.
* wcscpy: (libc)Copying and Concatenation.
* wcscspn: (libc)Search Functions.
* wcsdup: (libc)Copying and Concatenation.
* wcsftime: (libc)Formatting Calendar Time.
* wcslen: (libc)String Length.
* wcsncasecmp: (libc)String/Array Comparison.
* wcsncat: (libc)Copying and Concatenation.
* wcsncmp: (libc)String/Array Comparison.
* wcsncpy: (libc)Copying and Concatenation.
* wcsnlen: (libc)String Length.
* wcsnrtombs: (libc)Converting Strings.
* wcspbrk: (libc)Search Functions.
* wcsrchr: (libc)Search Functions.
* wcsrtombs: (libc)Converting Strings.
* wcsspn: (libc)Search Functions.
* wcsstr: (libc)Search Functions.
* wcstod: (libc)Parsing of Floats.
* wcstof: (libc)Parsing of Floats.
* wcstoimax: (libc)Parsing of Integers.
* wcstok: (libc)Finding Tokens in a String.
* wcstol: (libc)Parsing of Integers.
* wcstold: (libc)Parsing of Floats.
* wcstoll: (libc)Parsing of Integers.
* wcstombs: (libc)Non-reentrant String Conversion.
* wcstoq: (libc)Parsing of Integers.
* wcstoul: (libc)Parsing of Integers.
* wcstoull: (libc)Parsing of Integers.
* wcstoumax: (libc)Parsing of Integers.
* wcstouq: (libc)Parsing of Integers.
* wcswcs: (libc)Search Functions.
* wcsxfrm: (libc)Collation Functions.
* wctob: (libc)Converting a Character.
* wctomb: (libc)Non-reentrant Character Conversion.
* wctrans: (libc)Wide Character Case Conversion.
* wctype: (libc)Classification of Wide Characters.
* wmemchr: (libc)Search Functions.
* wmemcmp: (libc)String/Array Comparison.
* wmemcpy: (libc)Copying and Concatenation.
* wmemmove: (libc)Copying and Concatenation.
* wmempcpy: (libc)Copying and Concatenation.
* wmemset: (libc)Copying and Concatenation.
* wordexp: (libc)Calling Wordexp.
* wordfree: (libc)Calling Wordexp.
* wprintf: (libc)Formatted Output Functions.
* write: (libc)I/O Primitives.
* writev: (libc)Scatter-Gather.
* wscanf: (libc)Formatted Input Functions.
* y0: (libc)Special Functions.
* y0f: (libc)Special Functions.
* y0l: (libc)Special Functions.
* y1: (libc)Special Functions.
* y1f: (libc)Special Functions.
* y1l: (libc)Special Functions.
* yn: (libc)Special Functions.
* ynf: (libc)Special Functions.
* ynl: (libc)Special Functions.
END-INFO-DIR-ENTRY

   This file documents the GNU C library.

   This is Edition 0.12, last updated 2007-10-27, of `The GNU C Library
Reference Manual', for version 2.8.

   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,
2003, 2007, 2008 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software Needs Free Documentation" and
"GNU Lesser General Public License", the Front-Cover texts being "A GNU
Manual", and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom."


File: libc.info,  Node: Socket Concepts,  Next: Communication Styles,  Up: Sockets

16.1 Socket Concepts
====================

When you create a socket, you must specify the style of communication
you want to use and the type of protocol that should implement it.  The
"communication style" of a socket defines the user-level semantics of
sending and receiving data on the socket.  Choosing a communication
style specifies the answers to questions such as these:

   * *What are the units of data transmission?*  Some communication
     styles regard the data as a sequence of bytes with no larger
     structure; others group the bytes into records (which are known in
     this context as "packets").

   * *Can data be lost during normal operation?*  Some communication
     styles guarantee that all the data sent arrives in the order it was
     sent (barring system or network crashes); other styles occasionally
     lose data as a normal part of operation, and may sometimes deliver
     packets more than once or in the wrong order.

     Designing a program to use unreliable communication styles usually
     involves taking precautions to detect lost or misordered packets
     and to retransmit data as needed.

   * *Is communication entirely with one partner?*  Some communication
     styles are like a telephone call--you make a "connection" with one
     remote socket and then exchange data freely.  Other styles are
     like mailing letters--you specify a destination address for each
     message you send.

   You must also choose a "namespace" for naming the socket.  A socket
name ("address") is meaningful only in the context of a particular
namespace.  In fact, even the data type to use for a socket name may
depend on the namespace.  Namespaces are also called "domains", but we
avoid that word as it can be confused with other usage of the same
term.  Each namespace has a symbolic name that starts with `PF_'.  A
corresponding symbolic name starting with `AF_' designates the address
format for that namespace.

   Finally you must choose the "protocol" to carry out the
communication.  The protocol determines what low-level mechanism is used
to transmit and receive data.  Each protocol is valid for a particular
namespace and communication style; a namespace is sometimes called a
"protocol family" because of this, which is why the namespace names
start with `PF_'.

   The rules of a protocol apply to the data passing between two
programs, perhaps on different computers; most of these rules are
handled by the operating system and you need not know about them.  What
you do need to know about protocols is this:

   * In order to have communication between two sockets, they must
     specify the _same_ protocol.

   * Each protocol is meaningful with particular style/namespace
     combinations and cannot be used with inappropriate combinations.
     For example, the TCP protocol fits only the byte stream style of
     communication and the Internet namespace.

   * For each combination of style and namespace there is a "default
     protocol", which you can request by specifying 0 as the protocol
     number.  And that's what you should normally do--use the default.

   Throughout the following description at various places
variables/parameters to denote sizes are required.  And here the trouble
starts.  In the first implementations the type of these variables was
simply `int'.  On most machines at that time an `int' was 32 bits wide,
which created a _de facto_ standard requiring 32-bit variables.  This
is important since references to variables of this type are passed to
the kernel.

   Then the POSIX people came and unified the interface with the words
"all size values are of type `size_t'".  On 64-bit machines `size_t' is
64 bits wide, so pointers to variables were no longer possible.

   The Unix98 specification provides a solution by introducing a type
`socklen_t'.  This type is used in all of the cases that POSIX changed
to use `size_t'.  The only requirement of this type is that it be an
unsigned type of at least 32 bits.  Therefore, implementations which
require that references to 32-bit variables be passed can be as happy
as implementations which use 64-bit values.


File: libc.info,  Node: Communication Styles,  Next: Socket Addresses,  Prev: Socket Concepts,  Up: Sockets

16.2 Communication Styles
=========================

The GNU library includes support for several different kinds of sockets,
each with different characteristics.  This section describes the
supported socket types.  The symbolic constants listed here are defined
in `sys/socket.h'.  

 -- Macro: int SOCK_STREAM
     The `SOCK_STREAM' style is like a pipe (*note Pipes and FIFOs::).
     It operates over a connection with a particular remote socket and
     transmits data reliably as a stream of bytes.

     Use of this style is covered in detail in *note Connections::.

 -- Macro: int SOCK_DGRAM
     The `SOCK_DGRAM' style is used for sending individually-addressed
     packets unreliably.  It is the diametrical opposite of
     `SOCK_STREAM'.

     Each time you write data to a socket of this kind, that data
     becomes one packet.  Since `SOCK_DGRAM' sockets do not have
     connections, you must specify the recipient address with each
     packet.

     The only guarantee that the system makes about your requests to
     transmit data is that it will try its best to deliver each packet
     you send.  It may succeed with the sixth packet after failing with
     the fourth and fifth packets; the seventh packet may arrive before
     the sixth, and may arrive a second time after the sixth.

     The typical use for `SOCK_DGRAM' is in situations where it is
     acceptable to simply re-send a packet if no response is seen in a
     reasonable amount of time.

     *Note Datagrams::, for detailed information about how to use
     datagram sockets.

 -- Macro: int SOCK_RAW
     This style provides access to low-level network protocols and
     interfaces.  Ordinary user programs usually have no need to use
     this style.


File: libc.info,  Node: Socket Addresses,  Next: Interface Naming,  Prev: Communication Styles,  Up: Sockets

16.3 Socket Addresses
=====================

The name of a socket is normally called an "address".  The functions
and symbols for dealing with socket addresses were named
inconsistently, sometimes using the term "name" and sometimes using
"address".  You can regard these terms as synonymous where sockets are
concerned.

   A socket newly created with the `socket' function has no address.
Other processes can find it for communication only if you give it an
address.  We call this "binding" the address to the socket, and the way
to do it is with the `bind' function.

   You need be concerned with the address of a socket if other processes
are to find it and start communicating with it.  You can specify an
address for other sockets, but this is usually pointless; the first time
you send data from a socket, or use it to initiate a connection, the
system assigns an address automatically if you have not specified one.

   Occasionally a client needs to specify an address because the server
discriminates based on address; for example, the rsh and rlogin
protocols look at the client's socket address and only bypass password
checking if it is less than `IPPORT_RESERVED' (*note Ports::).

   The details of socket addresses vary depending on what namespace you
are using.  *Note Local Namespace::, or *note Internet Namespace::, for
specific information.

   Regardless of the namespace, you use the same functions `bind' and
`getsockname' to set and examine a socket's address.  These functions
use a phony data type, `struct sockaddr *', to accept the address.  In
practice, the address lives in a structure of some other data type
appropriate to the address format you are using, but you cast its
address to `struct sockaddr *' when you pass it to `bind'.

* Menu:

* Address Formats::		About `struct sockaddr'.
* Setting Address::		Binding an address to a socket.
* Reading Address::		Reading the address of a socket.


File: libc.info,  Node: Address Formats,  Next: Setting Address,  Up: Socket Addresses

16.3.1 Address Formats
----------------------

The functions `bind' and `getsockname' use the generic data type
`struct sockaddr *' to represent a pointer to a socket address.  You
can't use this data type effectively to interpret an address or
construct one; for that, you must use the proper data type for the
socket's namespace.

   Thus, the usual practice is to construct an address of the proper
namespace-specific type, then cast a pointer to `struct sockaddr *'
when you call `bind' or `getsockname'.

   The one piece of information that you can get from the `struct
sockaddr' data type is the "address format designator".  This tells you
which data type to use to understand the address fully.

   The symbols in this section are defined in the header file
`sys/socket.h'.

 -- Data Type: struct sockaddr
     The `struct sockaddr' type itself has the following members:

    `short int sa_family'
          This is the code for the address format of this address.  It
          identifies the format of the data which follows.

    `char sa_data[14]'
          This is the actual socket address data, which is
          format-dependent.  Its length also depends on the format, and
          may well be more than 14.  The length 14 of `sa_data' is
          essentially arbitrary.

   Each address format has a symbolic name which starts with `AF_'.
Each of them corresponds to a `PF_' symbol which designates the
corresponding namespace.  Here is a list of address format names:

`AF_LOCAL'
     This designates the address format that goes with the local
     namespace.  (`PF_LOCAL' is the name of that namespace.)  *Note
     Local Namespace Details::, for information about this address
     format.

`AF_UNIX'
     This is a synonym for `AF_LOCAL'.  Although `AF_LOCAL' is mandated
     by POSIX.1g, `AF_UNIX' is portable to more systems.  `AF_UNIX' was
     the traditional name stemming from BSD, so even most POSIX systems
     support it.  It is also the name of choice in the Unix98
     specification. (The same is true for `PF_UNIX' vs. `PF_LOCAL').

`AF_FILE'
     This is another synonym for `AF_LOCAL', for compatibility.
     (`PF_FILE' is likewise a synonym for `PF_LOCAL'.)

`AF_INET'
     This designates the address format that goes with the Internet
     namespace.  (`PF_INET' is the name of that namespace.)  *Note
     Internet Address Formats::.

`AF_INET6'
     This is similar to `AF_INET', but refers to the IPv6 protocol.
     (`PF_INET6' is the name of the corresponding namespace.)

`AF_UNSPEC'
     This designates no particular address format.  It is used only in
     rare cases, such as to clear out the default destination address
     of a "connected" datagram socket.  *Note Sending Datagrams::.

     The corresponding namespace designator symbol `PF_UNSPEC' exists
     for completeness, but there is no reason to use it in a program.

   `sys/socket.h' defines symbols starting with `AF_' for many
different kinds of networks, most or all of which are not actually
implemented.  We will document those that really work as we receive
information about how to use them.


File: libc.info,  Node: Setting Address,  Next: Reading Address,  Prev: Address Formats,  Up: Socket Addresses

16.3.2 Setting the Address of a Socket
--------------------------------------

Use the `bind' function to assign an address to a socket.  The
prototype for `bind' is in the header file `sys/socket.h'.  For
examples of use, see *note Local Socket Example::, or see *note Inet
Example::.

 -- Function: int bind (int SOCKET, struct sockaddr *ADDR, socklen_t
          LENGTH)
     The `bind' function assigns an address to the socket SOCKET.  The
     ADDR and LENGTH arguments specify the address; the detailed format
     of the address depends on the namespace.  The first part of the
     address is always the format designator, which specifies a
     namespace, and says that the address is in the format of that
     namespace.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `EADDRNOTAVAIL'
          The specified address is not available on this machine.

    `EADDRINUSE'
          Some other socket is already using the specified address.

    `EINVAL'
          The socket SOCKET already has an address.

    `EACCES'
          You do not have permission to access the requested address.
          (In the Internet domain, only the super-user is allowed to
          specify a port number in the range 0 through
          `IPPORT_RESERVED' minus one; see *note Ports::.)

     Additional conditions may be possible depending on the particular
     namespace of the socket.


File: libc.info,  Node: Reading Address,  Prev: Setting Address,  Up: Socket Addresses

16.3.3 Reading the Address of a Socket
--------------------------------------

Use the function `getsockname' to examine the address of an Internet
socket.  The prototype for this function is in the header file
`sys/socket.h'.

 -- Function: int getsockname (int SOCKET, struct sockaddr *ADDR,
          socklen_t *LENGTH-PTR)
     The `getsockname' function returns information about the address
     of the socket SOCKET in the locations specified by the ADDR and
     LENGTH-PTR arguments.  Note that the LENGTH-PTR is a pointer; you
     should initialize it to be the allocation size of ADDR, and on
     return it contains the actual size of the address data.

     The format of the address data depends on the socket namespace.
     The length of the information is usually fixed for a given
     namespace, so normally you can know exactly how much space is
     needed and can provide that much.  The usual practice is to
     allocate a place for the value using the proper data type for the
     socket's namespace, then cast its address to `struct sockaddr *'
     to pass it to `getsockname'.

     The return value is `0' on success and `-1' on error.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOBUFS'
          There are not enough internal buffers available for the
          operation.

   You can't read the address of a socket in the file namespace.  This
is consistent with the rest of the system; in general, there's no way to
find a file's name from a descriptor for that file.


File: libc.info,  Node: Interface Naming,  Next: Local Namespace,  Prev: Socket Addresses,  Up: Sockets

16.4 Interface Naming
=====================

Each network interface has a name.  This usually consists of a few
letters that relate to the type of interface, which may be followed by a
number if there is more than one interface of that type.  Examples
might be `lo' (the loopback interface) and `eth0' (the first Ethernet
interface).

   Although such names are convenient for humans, it would be clumsy to
have to use them whenever a program needs to refer to an interface.  In
such situations an interface is referred to by its "index", which is an
arbitrarily-assigned small positive integer.

   The following functions, constants and data types are declared in the
header file `net/if.h'.

 -- Constant: size_t IFNAMSIZ
     This constant defines the maximum buffer size needed to hold an
     interface name, including its terminating zero byte.

 -- Function: unsigned int if_nametoindex (const char *ifname)
     This function yields the interface index corresponding to a
     particular name.  If no interface exists with the name given, it
     returns 0.

 -- Function: char * if_indextoname (unsigned int ifindex, char *ifname)
     This function maps an interface index to its corresponding name.
     The returned name is placed in the buffer pointed to by `ifname',
     which must be at least `IFNAMSIZ' bytes in length.  If the index
     was invalid, the function's return value is a null pointer,
     otherwise it is `ifname'.

 -- Data Type: struct if_nameindex
     This data type is used to hold the information about a single
     interface.  It has the following members:

    `unsigned int if_index;'
          This is the interface index.

    `char *if_name'
          This is the null-terminated index name.


 -- Function: struct if_nameindex * if_nameindex (void)
     This function returns an array of `if_nameindex' structures, one
     for every interface that is present.  The end of the list is
     indicated by a structure with an interface of 0 and a null name
     pointer.  If an error occurs, this function returns a null pointer.

     The returned structure must be freed with `if_freenameindex' after
     use.

 -- Function: void if_freenameindex (struct if_nameindex *ptr)
     This function frees the structure returned by an earlier call to
     `if_nameindex'.


File: libc.info,  Node: Local Namespace,  Next: Internet Namespace,  Prev: Interface Naming,  Up: Sockets

16.5 The Local Namespace
========================

This section describes the details of the local namespace, whose
symbolic name (required when you create a socket) is `PF_LOCAL'.  The
local namespace is also known as "Unix domain sockets".  Another name
is file namespace since socket addresses are normally implemented as
file names.

* Menu:

* Concepts: Local Namespace Concepts. What you need to understand.
* Details: Local Namespace Details.   Address format, symbolic names, etc.
* Example: Local Socket Example.      Example of creating a socket.


File: libc.info,  Node: Local Namespace Concepts,  Next: Local Namespace Details,  Up: Local Namespace

16.5.1 Local Namespace Concepts
-------------------------------

In the local namespace socket addresses are file names.  You can specify
any file name you want as the address of the socket, but you must have
write permission on the directory containing it.  It's common to put
these files in the `/tmp' directory.

   One peculiarity of the local namespace is that the name is only used
when opening the connection; once open the address is not meaningful and
may not exist.

   Another peculiarity is that you cannot connect to such a socket from
another machine-not even if the other machine shares the file system
which contains the name of the socket.  You can see the socket in a
directory listing, but connecting to it never succeeds.  Some programs
take advantage of this, such as by asking the client to send its own
process ID, and using the process IDs to distinguish between clients.
However, we recommend you not use this method in protocols you design,
as we might someday permit connections from other machines that mount
the same file systems.  Instead, send each new client an identifying
number if you want it to have one.

   After you close a socket in the local namespace, you should delete
the file name from the file system.  Use `unlink' or `remove' to do
this; see *note Deleting Files::.

   The local namespace supports just one protocol for any communication
style; it is protocol number `0'.


File: libc.info,  Node: Local Namespace Details,  Next: Local Socket Example,  Prev: Local Namespace Concepts,  Up: Local Namespace

16.5.2 Details of Local Namespace
---------------------------------

To create a socket in the local namespace, use the constant `PF_LOCAL'
as the NAMESPACE argument to `socket' or `socketpair'.  This constant
is defined in `sys/socket.h'.

 -- Macro: int PF_LOCAL
     This designates the local namespace, in which socket addresses are
     local names, and its associated family of protocols.  `PF_Local'
     is the macro used by Posix.1g.

 -- Macro: int PF_UNIX
     This is a synonym for `PF_LOCAL', for compatibility's sake.

 -- Macro: int PF_FILE
     This is a synonym for `PF_LOCAL', for compatibility's sake.

   The structure for specifying socket names in the local namespace is
defined in the header file `sys/un.h': 

 -- Data Type: struct sockaddr_un
     This structure is used to specify local namespace socket
     addresses.  It has the following members:

    `short int sun_family'
          This identifies the address family or format of the socket
          address.  You should store the value `AF_LOCAL' to designate
          the local namespace.  *Note Socket Addresses::.

    `char sun_path[108]'
          This is the file name to use.

          *Incomplete:*  Why is 108 a magic number?  RMS suggests making
          this a zero-length array and tweaking the following example
          to use `alloca' to allocate an appropriate amount of storage
          based on the length of the filename.

   You should compute the LENGTH parameter for a socket address in the
local namespace as the sum of the size of the `sun_family' component
and the string length (_not_ the allocation size!) of the file name
string.  This can be done using the macro `SUN_LEN':

 -- Macro: int SUN_LEN (_struct sockaddr_un *_ PTR)
     The macro computes the length of socket address in the local
     namespace.


File: libc.info,  Node: Local Socket Example,  Prev: Local Namespace Details,  Up: Local Namespace

16.5.3 Example of Local-Namespace Sockets
-----------------------------------------

Here is an example showing how to create and name a socket in the local
namespace.

     #include <stddef.h>
     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <string.h>
     #include <sys/socket.h>
     #include <sys/un.h>

     int
     make_named_socket (const char *filename)
     {
       struct sockaddr_un name;
       int sock;
       size_t size;

       /* Create the socket. */
       sock = socket (PF_LOCAL, SOCK_DGRAM, 0);
       if (sock < 0)
         {
           perror ("socket");
           exit (EXIT_FAILURE);
         }

       /* Bind a name to the socket. */
       name.sun_family = AF_LOCAL;
       strncpy (name.sun_path, filename, sizeof (name.sun_path));
       name.sun_path[sizeof (name.sun_path) - 1] = '\0';

       /* The size of the address is
          the offset of the start of the filename,
          plus its length,
          plus one for the terminating null byte.
          Alternatively you can just do:
          size = SUN_LEN (&name);
      */
       size = (offsetof (struct sockaddr_un, sun_path)
               + strlen (name.sun_path) + 1);

       if (bind (sock, (struct sockaddr *) &name, size) < 0)
         {
           perror ("bind");
           exit (EXIT_FAILURE);
         }

       return sock;
     }


File: libc.info,  Node: Internet Namespace,  Next: Misc Namespaces,  Prev: Local Namespace,  Up: Sockets

16.6 The Internet Namespace
===========================

This section describes the details of the protocols and socket naming
conventions used in the Internet namespace.

   Originally the Internet namespace used only IP version 4 (IPv4).
With the growing number of hosts on the Internet, a new protocol with a
larger address space was necessary: IP version 6 (IPv6).  IPv6
introduces 128-bit addresses (IPv4 has 32-bit addresses) and other
features, and will eventually replace IPv4.

   To create a socket in the IPv4 Internet namespace, use the symbolic
name `PF_INET' of this namespace as the NAMESPACE argument to `socket'
or `socketpair'.  For IPv6 addresses you need the macro `PF_INET6'.
These macros are defined in `sys/socket.h'.  

 -- Macro: int PF_INET
     This designates the IPv4 Internet namespace and associated family
     of protocols.

 -- Macro: int PF_INET6
     This designates the IPv6 Internet namespace and associated family
     of protocols.

   A socket address for the Internet namespace includes the following
components:

   * The address of the machine you want to connect to.  Internet
     addresses can be specified in several ways; these are discussed in
     *note Internet Address Formats::, *note Host Addresses:: and *note
     Host Names::.

   * A port number for that machine.  *Note Ports::.

   You must ensure that the address and port number are represented in a
canonical format called "network byte order".  *Note Byte Order::, for
information about this.

* Menu:

* Internet Address Formats::    How socket addresses are specified in the
                                 Internet namespace.
* Host Addresses::	        All about host addresses of Internet host.
* Protocols Database::		Referring to protocols by name.
* Ports::			Internet port numbers.
* Services Database::           Ports may have symbolic names.
* Byte Order::		        Different hosts may use different byte
                                 ordering conventions; you need to
                                 canonicalize host address and port number.
* Inet Example::	        Putting it all together.


File: libc.info,  Node: Internet Address Formats,  Next: Host Addresses,  Up: Internet Namespace

16.6.1 Internet Socket Address Formats
--------------------------------------

In the Internet namespace, for both IPv4 (`AF_INET') and IPv6
(`AF_INET6'), a socket address consists of a host address and a port on
that host.  In addition, the protocol you choose serves effectively as
a part of the address because local port numbers are meaningful only
within a particular protocol.

   The data types for representing socket addresses in the Internet
namespace are defined in the header file `netinet/in.h'.  

 -- Data Type: struct sockaddr_in
     This is the data type used to represent socket addresses in the
     Internet namespace.  It has the following members:

    `sa_family_t sin_family'
          This identifies the address family or format of the socket
          address.  You should store the value `AF_INET' in this member.
          *Note Socket Addresses::.

    `struct in_addr sin_addr'
          This is the Internet address of the host machine.  *Note Host
          Addresses::, and *note Host Names::, for how to get a value
          to store here.

    `unsigned short int sin_port'
          This is the port number.  *Note Ports::.

   When you call `bind' or `getsockname', you should specify `sizeof
(struct sockaddr_in)' as the LENGTH parameter if you are using an IPv4
Internet namespace socket address.

 -- Data Type: struct sockaddr_in6
     This is the data type used to represent socket addresses in the
     IPv6 namespace.  It has the following members:

    `sa_family_t sin6_family'
          This identifies the address family or format of the socket
          address.  You should store the value of `AF_INET6' in this
          member.  *Note Socket Addresses::.

    `struct in6_addr sin6_addr'
          This is the IPv6 address of the host machine.  *Note Host
          Addresses::, and *note Host Names::, for how to get a value
          to store here.

    `uint32_t sin6_flowinfo'
          This is a currently unimplemented field.

    `uint16_t sin6_port'
          This is the port number.  *Note Ports::.



File: libc.info,  Node: Host Addresses,  Next: Protocols Database,  Prev: Internet Address Formats,  Up: Internet Namespace

16.6.2 Host Addresses
---------------------

Each computer on the Internet has one or more "Internet addresses",
numbers which identify that computer among all those on the Internet.
Users typically write IPv4 numeric host addresses as sequences of four
numbers, separated by periods, as in `128.52.46.32', and IPv6 numeric
host addresses as sequences of up to eight numbers separated by colons,
as in `5f03:1200:836f:c100::1'.

   Each computer also has one or more "host names", which are strings
of words separated by periods, as in `mescaline.gnu.org'.

   Programs that let the user specify a host typically accept both
numeric addresses and host names.  To open a connection a program needs
a numeric address, and so must convert a host name to the numeric
address it stands for.

* Menu:

* Abstract Host Addresses::	What a host number consists of.
* Data type: Host Address Data Type.	Data type for a host number.
* Functions: Host Address Functions.	Functions to operate on them.
* Names: Host Names.		Translating host names to host numbers.


File: libc.info,  Node: Abstract Host Addresses,  Next: Host Address Data Type,  Up: Host Addresses

16.6.2.1 Internet Host Addresses
................................

Each computer on the Internet has one or more Internet addresses,
numbers which identify that computer among all those on the Internet.

An IPv4 Internet host address is a number containing four bytes of data.
Historically these are divided into two parts, a "network number" and a
"local network address number" within that network.  In the mid-1990s
classless addresses were introduced which changed this behavior.  Since
some functions implicitly expect the old definitions, we first describe
the class-based network and will then describe classless addresses.
IPv6 uses only classless addresses and therefore the following
paragraphs don't apply.

   The class-based IPv4 network number consists of the first one, two or
three bytes; the rest of the bytes are the local address.

   IPv4 network numbers are registered with the Network Information
Center (NIC), and are divided into three classes--A, B and C.  The local
network address numbers of individual machines are registered with the
administrator of the particular network.

   Class A networks have single-byte numbers in the range 0 to 127.
There are only a small number of Class A networks, but they can each
support a very large number of hosts.  Medium-sized Class B networks
have two-byte network numbers, with the first byte in the range 128 to
191.  Class C networks are the smallest; they have three-byte network
numbers, with the first byte in the range 192-255.  Thus, the first 1,
2, or 3 bytes of an Internet address specify a network.  The remaining
bytes of the Internet address specify the address within that network.

   The Class A network 0 is reserved for broadcast to all networks.  In
addition, the host number 0 within each network is reserved for
broadcast to all hosts in that network.  These uses are obsolete now
but for compatibility reasons you shouldn't use network 0 and host
number 0.

   The Class A network 127 is reserved for loopback; you can always use
the Internet address `127.0.0.1' to refer to the host machine.

   Since a single machine can be a member of multiple networks, it can
have multiple Internet host addresses.  However, there is never
supposed to be more than one machine with the same host address.

   There are four forms of the "standard numbers-and-dots notation" for
Internet addresses:

`A.B.C.D'
     This specifies all four bytes of the address individually and is
     the commonly used representation.

`A.B.C'
     The last part of the address, C, is interpreted as a 2-byte
     quantity.  This is useful for specifying host addresses in a Class
     B network with network address number `A.B'.

`A.B'
     The last part of the address, B, is interpreted as a 3-byte
     quantity.  This is useful for specifying host addresses in a Class
     A network with network address number A.

`A'
     If only one part is given, this corresponds directly to the host
     address number.

   Within each part of the address, the usual C conventions for
specifying the radix apply.  In other words, a leading `0x' or `0X'
implies hexadecimal radix; a leading `0' implies octal; and otherwise
decimal radix is assumed.

Classless Addresses
...................

IPv4 addresses (and IPv6 addresses also) are now considered classless;
the distinction between classes A, B and C can be ignored.  Instead an
IPv4 host address consists of a 32-bit address and a 32-bit mask.  The
mask contains set bits for the network part and cleared bits for the
host part.  The network part is contiguous from the left, with the
remaining bits representing the host.  As a consequence, the netmask can
simply be specified as the number of set bits.  Classes A, B and C are
just special cases of this general rule.  For example, class A addresses
have a netmask of `255.0.0.0' or a prefix length of 8.

   Classless IPv4 network addresses are written in numbers-and-dots
notation with the prefix length appended and a slash as separator.  For
example the class A network 10 is written as `10.0.0.0/8'.

IPv6 Addresses
..............

IPv6 addresses contain 128 bits (IPv4 has 32 bits) of data.  A host
address is usually written as eight 16-bit hexadecimal numbers that are
separated by colons.  Two colons are used to abbreviate strings of
consecutive zeros.  For example, the IPv6 loopback address
`0:0:0:0:0:0:0:1' can just be written as `::1'.


File: libc.info,  Node: Host Address Data Type,  Next: Host Address Functions,  Prev: Abstract Host Addresses,  Up: Host Addresses

16.6.2.2 Host Address Data Type
...............................

IPv4 Internet host addresses are represented in some contexts as
integers (type `uint32_t').  In other contexts, the integer is packaged
inside a structure of type `struct in_addr'.  It would be better if the
usage were made consistent, but it is not hard to extract the integer
from the structure or put the integer into a structure.

   You will find older code that uses `unsigned long int' for IPv4
Internet host addresses instead of `uint32_t' or `struct in_addr'.
Historically `unsigned long int' was a 32-bit number but with 64-bit
machines this has changed.  Using `unsigned long int' might break the
code if it is used on machines where this type doesn't have 32 bits.
`uint32_t' is specified by Unix98 and guaranteed to have 32 bits.

   IPv6 Internet host addresses have 128 bits and are packaged inside a
structure of type `struct in6_addr'.

   The following basic definitions for Internet addresses are declared
in the header file `netinet/in.h': 

 -- Data Type: struct in_addr
     This data type is used in certain contexts to contain an IPv4
     Internet host address.  It has just one field, named `s_addr',
     which records the host address number as an `uint32_t'.

 -- Macro: uint32_t INADDR_LOOPBACK
     You can use this constant to stand for "the address of this
     machine," instead of finding its actual address.  It is the IPv4
     Internet address `127.0.0.1', which is usually called `localhost'.
     This special constant saves you the trouble of looking up the
     address of your own machine.  Also, the system usually implements
     `INADDR_LOOPBACK' specially, avoiding any network traffic for the
     case of one machine talking to itself.

 -- Macro: uint32_t INADDR_ANY
     You can use this constant to stand for "any incoming address" when
     binding to an address.  *Note Setting Address::.  This is the usual
     address to give in the `sin_addr' member of `struct sockaddr_in'
     when you want to accept Internet connections.

 -- Macro: uint32_t INADDR_BROADCAST
     This constant is the address you use to send a broadcast message.

 -- Macro: uint32_t INADDR_NONE
     This constant is returned by some functions to indicate an error.

 -- Data Type: struct in6_addr
     This data type is used to store an IPv6 address.  It stores 128
     bits of data, which can be accessed (via a union) in a variety of
     ways.

 -- Constant: struct in6_addr in6addr_loopback
     This constant is the IPv6 address `::1', the loopback address.  See
     above for a description of what this means.  The macro
     `IN6ADDR_LOOPBACK_INIT' is provided to allow you to initialize your
     own variables to this value.

 -- Constant: struct in6_addr in6addr_any
     This constant is the IPv6 address `::', the unspecified address.
     See above for a description of what this means.  The macro
     `IN6ADDR_ANY_INIT' is provided to allow you to initialize your own
     variables to this value.


File: libc.info,  Node: Host Address Functions,  Next: Host Names,  Prev: Host Address Data Type,  Up: Host Addresses

16.6.2.3 Host Address Functions
...............................

These additional functions for manipulating Internet addresses are
declared in the header file `arpa/inet.h'.  They represent Internet
addresses in network byte order, and network numbers and
local-address-within-network numbers in host byte order.  *Note Byte
Order::, for an explanation of network and host byte order.

 -- Function: int inet_aton (const char *NAME, struct in_addr *ADDR)
     This function converts the IPv4 Internet host address NAME from
     the standard numbers-and-dots notation into binary data and stores
     it in the `struct in_addr' that ADDR points to.  `inet_aton'
     returns nonzero if the address is valid, zero if not.

 -- Function: uint32_t inet_addr (const char *NAME)
     This function converts the IPv4 Internet host address NAME from the
     standard numbers-and-dots notation into binary data.  If the input
     is not valid, `inet_addr' returns `INADDR_NONE'.  This is an
     obsolete interface to `inet_aton', described immediately above. It
     is obsolete because `INADDR_NONE' is a valid address
     (255.255.255.255), and `inet_aton' provides a cleaner way to
     indicate error return.

 -- Function: uint32_t inet_network (const char *NAME)
     This function extracts the network number from the address NAME,
     given in the standard numbers-and-dots notation. The returned
     address is in host order. If the input is not valid,
     `inet_network' returns `-1'.

     The function works only with traditional IPv4 class A, B and C
     network types.  It doesn't work with classless addresses and
     shouldn't be used anymore.

 -- Function: char * inet_ntoa (struct in_addr ADDR)
     This function converts the IPv4 Internet host address ADDR to a
     string in the standard numbers-and-dots notation.  The return
     value is a pointer into a statically-allocated buffer.  Subsequent
     calls will overwrite the same buffer, so you should copy the
     string if you need to save it.

     In multi-threaded programs each thread has an own
     statically-allocated buffer.  But still subsequent calls of
     `inet_ntoa' in the same thread will overwrite the result of the
     last call.

     Instead of `inet_ntoa' the newer function `inet_ntop' which is
     described below should be used since it handles both IPv4 and IPv6
     addresses.

 -- Function: struct in_addr inet_makeaddr (uint32_t NET, uint32_t
          LOCAL)
     This function makes an IPv4 Internet host address by combining the
     network number NET with the local-address-within-network number
     LOCAL.

 -- Function: uint32_t inet_lnaof (struct in_addr ADDR)
     This function returns the local-address-within-network part of the
     Internet host address ADDR.

     The function works only with traditional IPv4 class A, B and C
     network types.  It doesn't work with classless addresses and
     shouldn't be used anymore.

 -- Function: uint32_t inet_netof (struct in_addr ADDR)
     This function returns the network number part of the Internet host
     address ADDR.

     The function works only with traditional IPv4 class A, B and C
     network types.  It doesn't work with classless addresses and
     shouldn't be used anymore.

 -- Function: int inet_pton (int AF, const char *CP, void *BUF)
     This function converts an Internet address (either IPv4 or IPv6)
     from presentation (textual) to network (binary) format.  AF should
     be either `AF_INET' or `AF_INET6', as appropriate for the type of
     address being converted.  CP is a pointer to the input string, and
     BUF is a pointer to a buffer for the result.  It is the caller's
     responsibility to make sure the buffer is large enough.

 -- Function: const char * inet_ntop (int AF, const void *CP, char
          *BUF, size_t LEN)
     This function converts an Internet address (either IPv4 or IPv6)
     from network (binary) to presentation (textual) form.  AF should be
     either `AF_INET' or `AF_INET6', as appropriate.  CP is a pointer
     to the address to be converted.  BUF should be a pointer to a
     buffer to hold the result, and LEN is the length of this buffer.
     The return value from the function will be this buffer address.


File: libc.info,  Node: Host Names,  Prev: Host Address Functions,  Up: Host Addresses

16.6.2.4 Host Names
...................

Besides the standard numbers-and-dots notation for Internet addresses,
you can also refer to a host by a symbolic name.  The advantage of a
symbolic name is that it is usually easier to remember.  For example,
the machine with Internet address `158.121.106.19' is also known as
`alpha.gnu.org'; and other machines in the `gnu.org' domain can refer
to it simply as `alpha'.

   Internally, the system uses a database to keep track of the mapping
between host names and host numbers.  This database is usually either
the file `/etc/hosts' or an equivalent provided by a name server.  The
functions and other symbols for accessing this database are declared in
`netdb.h'.  They are BSD features, defined unconditionally if you
include `netdb.h'.

 -- Data Type: struct hostent
     This data type is used to represent an entry in the hosts
     database.  It has the following members:

    `char *h_name'
          This is the "official" name of the host.

    `char **h_aliases'
          These are alternative names for the host, represented as a
          null-terminated vector of strings.

    `int h_addrtype'
          This is the host address type; in practice, its value is
          always either `AF_INET' or `AF_INET6', with the latter being
          used for IPv6 hosts.  In principle other kinds of addresses
          could be represented in the database as well as Internet
          addresses; if this were done, you might find a value in this
          field other than `AF_INET' or `AF_INET6'.  *Note Socket
          Addresses::.

    `int h_length'
          This is the length, in bytes, of each address.

    `char **h_addr_list'
          This is the vector of addresses for the host.  (Recall that
          the host might be connected to multiple networks and have
          different addresses on each one.)  The vector is terminated
          by a null pointer.

    `char *h_addr'
          This is a synonym for `h_addr_list[0]'; in other words, it is
          the first host address.

   As far as the host database is concerned, each address is just a
block of memory `h_length' bytes long.  But in other contexts there is
an implicit assumption that you can convert IPv4 addresses to a `struct
in_addr' or an `uint32_t'.  Host addresses in a `struct hostent'
structure are always given in network byte order; see *note Byte
Order::.

   You can use `gethostbyname', `gethostbyname2' or `gethostbyaddr' to
search the hosts database for information about a particular host.  The
information is returned in a statically-allocated structure; you must
copy the information if you need to save it across calls.  You can also
use `getaddrinfo' and `getnameinfo' to obtain this information.

 -- Function: struct hostent * gethostbyname (const char *NAME)
     The `gethostbyname' function returns information about the host
     named NAME.  If the lookup fails, it returns a null pointer.

 -- Function: struct hostent * gethostbyname2 (const char *NAME, int AF)
     The `gethostbyname2' function is like `gethostbyname', but allows
     the caller to specify the desired address family (e.g.  `AF_INET'
     or `AF_INET6') of the result.

 -- Function: struct hostent * gethostbyaddr (const char *ADDR, size_t
          LENGTH, int FORMAT)
     The `gethostbyaddr' function returns information about the host
     with Internet address ADDR.  The parameter ADDR is not really a
     pointer to char - it can be a pointer to an IPv4 or an IPv6
     address. The LENGTH argument is the size (in bytes) of the address
     at ADDR.  FORMAT specifies the address format; for an IPv4
     Internet address, specify a value of `AF_INET'; for an IPv6
     Internet address, use `AF_INET6'.

     If the lookup fails, `gethostbyaddr' returns a null pointer.

   If the name lookup by `gethostbyname' or `gethostbyaddr' fails, you
can find out the reason by looking at the value of the variable
`h_errno'.  (It would be cleaner design for these functions to set
`errno', but use of `h_errno' is compatible with other systems.)

   Here are the error codes that you may find in `h_errno':

`HOST_NOT_FOUND'
     No such host is known in the database.

`TRY_AGAIN'
     This condition happens when the name server could not be
     contacted.  If you try again later, you may succeed then.

`NO_RECOVERY'
     A non-recoverable error occurred.

`NO_ADDRESS'
     The host database contains an entry for the name, but it doesn't
     have an associated Internet address.

   The lookup functions above all have one in common: they are not
reentrant and therefore unusable in multi-threaded applications.
Therefore provides the GNU C library a new set of functions which can be
used in this context.

 -- Function: int gethostbyname_r (const char *restrict NAME, struct
          hostent *restrict RESULT_BUF, char *restrict BUF, size_t
          BUFLEN, struct hostent **restrict RESULT, int *restrict
          H_ERRNOP)
     The `gethostbyname_r' function returns information about the host
     named NAME.  The caller must pass a pointer to an object of type
     `struct hostent' in the RESULT_BUF parameter.  In addition the
     function may need extra buffer space and the caller must pass an
     pointer and the size of the buffer in the BUF and BUFLEN
     parameters.

     A pointer to the buffer, in which the result is stored, is
     available in `*RESULT' after the function call successfully
     returned.  If an error occurs or if no entry is found, the pointer
     `*RESULT' is a null pointer.  Success is signalled by a zero
     return value.  If the function failed the return value is an error
     number.  In addition to the errors defined for `gethostbyname' it
     can also be `ERANGE'.  In this case the call should be repeated
     with a larger buffer.  Additional error information is not stored
     in the global variable `h_errno' but instead in the object pointed
     to by H_ERRNOP.

     Here's a small example:
          struct hostent *
          gethostname (char *host)
          {
            struct hostent hostbuf, *hp;
            size_t hstbuflen;
            char *tmphstbuf;
            int res;
            int herr;

            hstbuflen = 1024;
            /* Allocate buffer, remember to free it to avoid memory leakage.  */
            tmphstbuf = malloc (hstbuflen);

            while ((res = gethostbyname_r (host, &hostbuf, tmphstbuf, hstbuflen,
                                           &hp, &herr)) == ERANGE)
              {
                /* Enlarge the buffer.  */
                hstbuflen *= 2;
                tmphstbuf = realloc (tmphstbuf, hstbuflen);
              }
            /*  Check for errors.  */
            if (res || hp == NULL)
              return NULL;
            return hp;
          }

 -- Function: int gethostbyname2_r (const char *NAME, int AF, struct
          hostent *restrict RESULT_BUF, char *restrict BUF, size_t
          BUFLEN, struct hostent **restrict RESULT, int *restrict
          H_ERRNOP)
     The `gethostbyname2_r' function is like `gethostbyname_r', but
     allows the caller to specify the desired address family (e.g.
     `AF_INET' or `AF_INET6') for the result.

 -- Function: int gethostbyaddr_r (const char *ADDR, size_t LENGTH, int
          FORMAT, struct hostent *restrict RESULT_BUF, char *restrict
          BUF, size_t BUFLEN, struct hostent **restrict RESULT, int
          *restrict H_ERRNOP)
     The `gethostbyaddr_r' function returns information about the host
     with Internet address ADDR.  The parameter ADDR is not really a
     pointer to char - it can be a pointer to an IPv4 or an IPv6
     address. The LENGTH argument is the size (in bytes) of the address
     at ADDR.  FORMAT specifies the address format; for an IPv4
     Internet address, specify a value of `AF_INET'; for an IPv6
     Internet address, use `AF_INET6'.

     Similar to the `gethostbyname_r' function, the caller must provide
     buffers for the result and memory used internally.  In case of
     success the function returns zero.  Otherwise the value is an
     error number where `ERANGE' has the special meaning that the
     caller-provided buffer is too small.

   You can also scan the entire hosts database one entry at a time using
`sethostent', `gethostent' and `endhostent'.  Be careful when using
these functions because they are not reentrant.

 -- Function: void sethostent (int STAYOPEN)
     This function opens the hosts database to begin scanning it.  You
     can then call `gethostent' to read the entries.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `gethostbyname' or `gethostbyaddr' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 -- Function: struct hostent * gethostent (void)
     This function returns the next entry in the hosts database.  It
     returns a null pointer if there are no more entries.

 -- Function: void endhostent (void)
     This function closes the hosts database.


File: libc.info,  Node: Ports,  Next: Services Database,  Prev: Protocols Database,  Up: Internet Namespace

16.6.3 Internet Ports
---------------------

A socket address in the Internet namespace consists of a machine's
Internet address plus a "port number" which distinguishes the sockets
on a given machine (for a given protocol).  Port numbers range from 0
to 65,535.

   Port numbers less than `IPPORT_RESERVED' are reserved for standard
servers, such as `finger' and `telnet'.  There is a database that keeps
track of these, and you can use the `getservbyname' function to map a
service name onto a port number; see *note Services Database::.

   If you write a server that is not one of the standard ones defined in
the database, you must choose a port number for it.  Use a number
greater than `IPPORT_USERRESERVED'; such numbers are reserved for
servers and won't ever be generated automatically by the system.
Avoiding conflicts with servers being run by other users is up to you.

   When you use a socket without specifying its address, the system
generates a port number for it.  This number is between
`IPPORT_RESERVED' and `IPPORT_USERRESERVED'.

   On the Internet, it is actually legitimate to have two different
sockets with the same port number, as long as they never both try to
communicate with the same socket address (host address plus port
number).  You shouldn't duplicate a port number except in special
circumstances where a higher-level protocol requires it.  Normally, the
system won't let you do it; `bind' normally insists on distinct port
numbers.  To reuse a port number, you must set the socket option
`SO_REUSEADDR'.  *Note Socket-Level Options::.

   These macros are defined in the header file `netinet/in.h'.

 -- Macro: int IPPORT_RESERVED
     Port numbers less than `IPPORT_RESERVED' are reserved for
     superuser use.

 -- Macro: int IPPORT_USERRESERVED
     Port numbers greater than or equal to `IPPORT_USERRESERVED' are
     reserved for explicit use; they will never be allocated
     automatically.


File: libc.info,  Node: Services Database,  Next: Byte Order,  Prev: Ports,  Up: Internet Namespace

16.6.4 The Services Database
----------------------------

The database that keeps track of "well-known" services is usually
either the file `/etc/services' or an equivalent from a name server.
You can use these utilities, declared in `netdb.h', to access the
services database.  

 -- Data Type: struct servent
     This data type holds information about entries from the services
     database.  It has the following members:

    `char *s_name'
          This is the "official" name of the service.

    `char **s_aliases'
          These are alternate names for the service, represented as an
          array of strings.  A null pointer terminates the array.

    `int s_port'
          This is the port number for the service.  Port numbers are
          given in network byte order; see *note Byte Order::.

    `char *s_proto'
          This is the name of the protocol to use with this service.
          *Note Protocols Database::.

   To get information about a particular service, use the
`getservbyname' or `getservbyport' functions.  The information is
returned in a statically-allocated structure; you must copy the
information if you need to save it across calls.

 -- Function: struct servent * getservbyname (const char *NAME, const
          char *PROTO)
     The `getservbyname' function returns information about the service
     named NAME using protocol PROTO.  If it can't find such a service,
     it returns a null pointer.

     This function is useful for servers as well as for clients; servers
     use it to determine which port they should listen on (*note
     Listening::).

 -- Function: struct servent * getservbyport (int PORT, const char
          *PROTO)
     The `getservbyport' function returns information about the service
     at port PORT using protocol PROTO.  If it can't find such a
     service, it returns a null pointer.

You can also scan the services database using `setservent',
`getservent' and `endservent'.  Be careful when using these functions
because they are not reentrant.

 -- Function: void setservent (int STAYOPEN)
     This function opens the services database to begin scanning it.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getservbyname' or `getservbyport' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 -- Function: struct servent * getservent (void)
     This function returns the next entry in the services database.  If
     there are no more entries, it returns a null pointer.

 -- Function: void endservent (void)
     This function closes the services database.


File: libc.info,  Node: Byte Order,  Next: Inet Example,  Prev: Services Database,  Up: Internet Namespace

16.6.5 Byte Order Conversion
----------------------------

Different kinds of computers use different conventions for the ordering
of bytes within a word.  Some computers put the most significant byte
within a word first (this is called "big-endian" order), and others put
it last ("little-endian" order).

   So that machines with different byte order conventions can
communicate, the Internet protocols specify a canonical byte order
convention for data transmitted over the network.  This is known as
"network byte order".

   When establishing an Internet socket connection, you must make sure
that the data in the `sin_port' and `sin_addr' members of the
`sockaddr_in' structure are represented in network byte order.  If you
are encoding integer data in the messages sent through the socket, you
should convert this to network byte order too.  If you don't do this,
your program may fail when running on or talking to other kinds of
machines.

   If you use `getservbyname' and `gethostbyname' or `inet_addr' to get
the port number and host address, the values are already in network
byte order, and you can copy them directly into the `sockaddr_in'
structure.

   Otherwise, you have to convert the values explicitly.  Use `htons'
and `ntohs' to convert values for the `sin_port' member.  Use `htonl'
and `ntohl' to convert IPv4 addresses for the `sin_addr' member.
(Remember, `struct in_addr' is equivalent to `uint32_t'.)  These
functions are declared in `netinet/in.h'.  

 -- Function: uint16_t htons (uint16_t HOSTSHORT)
     This function converts the `uint16_t' integer HOSTSHORT from host
     byte order to network byte order.

 -- Function: uint16_t ntohs (uint16_t NETSHORT)
     This function converts the `uint16_t' integer NETSHORT from
     network byte order to host byte order.

 -- Function: uint32_t htonl (uint32_t HOSTLONG)
     This function converts the `uint32_t' integer HOSTLONG from host
     byte order to network byte order.

     This is used for IPv4 Internet addresses.

 -- Function: uint32_t ntohl (uint32_t NETLONG)
     This function converts the `uint32_t' integer NETLONG from network
     byte order to host byte order.

     This is used for IPv4 Internet addresses.


File: libc.info,  Node: Protocols Database,  Next: Ports,  Prev: Host Addresses,  Up: Internet Namespace

16.6.6 Protocols Database
-------------------------

The communications protocol used with a socket controls low-level
details of how data are exchanged.  For example, the protocol implements
things like checksums to detect errors in transmissions, and routing
instructions for messages.  Normal user programs have little reason to
mess with these details directly.

   The default communications protocol for the Internet namespace
depends on the communication style.  For stream communication, the
default is TCP ("transmission control protocol").  For datagram
communication, the default is UDP ("user datagram protocol").  For
reliable datagram communication, the default is RDP ("reliable datagram
protocol").  You should nearly always use the default.

   Internet protocols are generally specified by a name instead of a
number.  The network protocols that a host knows about are stored in a
database.  This is usually either derived from the file
`/etc/protocols', or it may be an equivalent provided by a name server.
You look up the protocol number associated with a named protocol in the
database using the `getprotobyname' function.

   Here are detailed descriptions of the utilities for accessing the
protocols database.  These are declared in `netdb.h'.  

 -- Data Type: struct protoent
     This data type is used to represent entries in the network
     protocols database.  It has the following members:

    `char *p_name'
          This is the official name of the protocol.

    `char **p_aliases'
          These are alternate names for the protocol, specified as an
          array of strings.  The last element of the array is a null
          pointer.

    `int p_proto'
          This is the protocol number (in host byte order); use this
          member as the PROTOCOL argument to `socket'.

   You can use `getprotobyname' and `getprotobynumber' to search the
protocols database for a specific protocol.  The information is
returned in a statically-allocated structure; you must copy the
information if you need to save it across calls.

 -- Function: struct protoent * getprotobyname (const char *NAME)
     The `getprotobyname' function returns information about the
     network protocol named NAME.  If there is no such protocol, it
     returns a null pointer.

 -- Function: struct protoent * getprotobynumber (int PROTOCOL)
     The `getprotobynumber' function returns information about the
     network protocol with number PROTOCOL.  If there is no such
     protocol, it returns a null pointer.

   You can also scan the whole protocols database one protocol at a
time by using `setprotoent', `getprotoent' and `endprotoent'.  Be
careful when using these functions because they are not reentrant.

 -- Function: void setprotoent (int STAYOPEN)
     This function opens the protocols database to begin scanning it.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getprotobyname' or `getprotobynumber' will
     not close the database (as they usually would).  This makes for
     more efficiency if you call those functions several times, by
     avoiding reopening the database for each call.

 -- Function: struct protoent * getprotoent (void)
     This function returns the next entry in the protocols database.  It
     returns a null pointer if there are no more entries.

 -- Function: void endprotoent (void)
     This function closes the protocols database.


File: libc.info,  Node: Inet Example,  Prev: Byte Order,  Up: Internet Namespace

16.6.7 Internet Socket Example
------------------------------

Here is an example showing how to create and name a socket in the
Internet namespace.  The newly created socket exists on the machine that
the program is running on.  Rather than finding and using the machine's
Internet address, this example specifies `INADDR_ANY' as the host
address; the system replaces that with the machine's actual address.

     #include <stdio.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <netinet/in.h>

     int
     make_socket (uint16_t port)
     {
       int sock;
       struct sockaddr_in name;

       /* Create the socket. */
       sock = socket (PF_INET, SOCK_STREAM, 0);
       if (sock < 0)
         {
           perror ("socket");
           exit (EXIT_FAILURE);
         }

       /* Give the socket a name. */
       name.sin_family = AF_INET;
       name.sin_port = htons (port);
       name.sin_addr.s_addr = htonl (INADDR_ANY);
       if (bind (sock, (struct sockaddr *) &name, sizeof (name)) < 0)
         {
           perror ("bind");
           exit (EXIT_FAILURE);
         }

       return sock;
     }

   Here is another example, showing how you can fill in a `sockaddr_in'
structure, given a host name string and a port number:

     #include <stdio.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <netdb.h>

     void
     init_sockaddr (struct sockaddr_in *name,
                    const char *hostname,
                    uint16_t port)
     {
       struct hostent *hostinfo;

       name->sin_family = AF_INET;
       name->sin_port = htons (port);
       hostinfo = gethostbyname (hostname);
       if (hostinfo == NULL)
         {
           fprintf (stderr, "Unknown host %s.\n", hostname);
           exit (EXIT_FAILURE);
         }
       name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
     }


File: libc.info,  Node: Misc Namespaces,  Next: Open/Close Sockets,  Prev: Internet Namespace,  Up: Sockets

16.7 Other Namespaces
=====================

Certain other namespaces and associated protocol families are supported
but not documented yet because they are not often used.  `PF_NS' refers
to the Xerox Network Software protocols.  `PF_ISO' stands for Open
Systems Interconnect.  `PF_CCITT' refers to protocols from CCITT.
`socket.h' defines these symbols and others naming protocols not
actually implemented.

   `PF_IMPLINK' is used for communicating between hosts and Internet
Message Processors.  For information on this and `PF_ROUTE', an
occasionally-used local area routing protocol, see the GNU Hurd Manual
(to appear in the future).


File: libc.info,  Node: Open/Close Sockets,  Next: Connections,  Prev: Misc Namespaces,  Up: Sockets

16.8 Opening and Closing Sockets
================================

This section describes the actual library functions for opening and
closing sockets.  The same functions work for all namespaces and
connection styles.

* Menu:

* Creating a Socket::           How to open a socket.
* Closing a Socket::            How to close a socket.
* Socket Pairs::                These are created like pipes.


File: libc.info,  Node: Creating a Socket,  Next: Closing a Socket,  Up: Open/Close Sockets

16.8.1 Creating a Socket
------------------------

The primitive for creating a socket is the `socket' function, declared
in `sys/socket.h'.  

 -- Function: int socket (int NAMESPACE, int STYLE, int PROTOCOL)
     This function creates a socket and specifies communication style
     STYLE, which should be one of the socket styles listed in *note
     Communication Styles::.  The NAMESPACE argument specifies the
     namespace; it must be `PF_LOCAL' (*note Local Namespace::) or
     `PF_INET' (*note Internet Namespace::).  PROTOCOL designates the
     specific protocol (*note Socket Concepts::); zero is usually right
     for PROTOCOL.

     The return value from `socket' is the file descriptor for the new
     socket, or `-1' in case of error.  The following `errno' error
     conditions are defined for this function:

    `EPROTONOSUPPORT'
          The PROTOCOL or STYLE is not supported by the NAMESPACE
          specified.

    `EMFILE'
          The process already has too many file descriptors open.

    `ENFILE'
          The system already has too many file descriptors open.

    `EACCES'
          The process does not have the privilege to create a socket of
          the specified STYLE or PROTOCOL.

    `ENOBUFS'
          The system ran out of internal buffer space.

     The file descriptor returned by the `socket' function supports both
     read and write operations.  However, like pipes, sockets do not
     support file positioning operations.

   For examples of how to call the `socket' function, see *note Local
Socket Example::, or *note Inet Example::.


File: libc.info,  Node: Closing a Socket,  Next: Socket Pairs,  Prev: Creating a Socket,  Up: Open/Close Sockets

16.8.2 Closing a Socket
-----------------------

When you have finished using a socket, you can simply close its file
descriptor with `close'; see *note Opening and Closing Files::.  If
there is still data waiting to be transmitted over the connection,
normally `close' tries to complete this transmission.  You can control
this behavior using the `SO_LINGER' socket option to specify a timeout
period; see *note Socket Options::.

   You can also shut down only reception or transmission on a
connection by calling `shutdown', which is declared in `sys/socket.h'.

 -- Function: int shutdown (int SOCKET, int HOW)
     The `shutdown' function shuts down the connection of socket
     SOCKET.  The argument HOW specifies what action to perform:

    `0'
          Stop receiving data for this socket.  If further data arrives,
          reject it.

    `1'
          Stop trying to transmit data from this socket.  Discard any
          data waiting to be sent.  Stop looking for acknowledgement of
          data already sent; don't retransmit it if it is lost.

    `2'
          Stop both reception and transmission.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          SOCKET is not a socket.

    `ENOTCONN'
          SOCKET is not connected.


File: libc.info,  Node: Socket Pairs,  Prev: Closing a Socket,  Up: Open/Close Sockets

16.8.3 Socket Pairs
-------------------

A "socket pair" consists of a pair of connected (but unnamed) sockets.
It is very similar to a pipe and is used in much the same way.  Socket
pairs are created with the `socketpair' function, declared in
`sys/socket.h'.  A socket pair is much like a pipe; the main difference
is that the socket pair is bidirectional, whereas the pipe has one
input-only end and one output-only end (*note Pipes and FIFOs::).

 -- Function: int socketpair (int NAMESPACE, int STYLE, int PROTOCOL,
          int FILEDES[2])
     This function creates a socket pair, returning the file
     descriptors in `FILEDES[0]' and `FILEDES[1]'.  The socket pair is
     a full-duplex communications channel, so that both reading and
     writing may be performed at either end.

     The NAMESPACE, STYLE and PROTOCOL arguments are interpreted as for
     the `socket' function.  STYLE should be one of the communication
     styles listed in *note Communication Styles::.  The NAMESPACE
     argument specifies the namespace, which must be `AF_LOCAL' (*note
     Local Namespace::); PROTOCOL specifies the communications
     protocol, but zero is the only meaningful value.

     If STYLE specifies a connectionless communication style, then the
     two sockets you get are not _connected_, strictly speaking, but
     each of them knows the other as the default destination address,
     so they can send packets to each other.

     The `socketpair' function returns `0' on success and `-1' on
     failure.  The following `errno' error conditions are defined for
     this function:

    `EMFILE'
          The process has too many file descriptors open.

    `EAFNOSUPPORT'
          The specified namespace is not supported.

    `EPROTONOSUPPORT'
          The specified protocol is not supported.

    `EOPNOTSUPP'
          The specified protocol does not support the creation of
          socket pairs.


File: libc.info,  Node: Connections,  Next: Datagrams,  Prev: Open/Close Sockets,  Up: Sockets

16.9 Using Sockets with Connections
===================================

The most common communication styles involve making a connection to a
particular other socket, and then exchanging data with that socket over
and over.  Making a connection is asymmetric; one side (the "client")
acts to request a connection, while the other side (the "server") makes
a socket and waits for the connection request.

* Menu:

* Connecting::    	     What the client program must do.
* Listening::		     How a server program waits for requests.
* Accepting Connections::    What the server does when it gets a request.
* Who is Connected::	     Getting the address of the
				other side of a connection.
* Transferring Data::        How to send and receive data.
* Byte Stream Example::	     An example program: a client for communicating
			      over a byte stream socket in the Internet namespace.
* Server Example::	     A corresponding server program.
* Out-of-Band Data::         This is an advanced feature.


File: libc.info,  Node: Connecting,  Next: Listening,  Up: Connections

16.9.1 Making a Connection
--------------------------

In making a connection, the client makes a connection while the server
waits for and accepts the connection.  Here we discuss what the client
program must do with the `connect' function, which is declared in
`sys/socket.h'.

 -- Function: int connect (int SOCKET, struct sockaddr *ADDR, socklen_t
          LENGTH)
     The `connect' function initiates a connection from the socket with
     file descriptor SOCKET to the socket whose address is specified by
     the ADDR and LENGTH arguments.  (This socket is typically on
     another machine, and it must be already set up as a server.)
     *Note Socket Addresses::, for information about how these
     arguments are interpreted.

     Normally, `connect' waits until the server responds to the request
     before it returns.  You can set nonblocking mode on the socket
     SOCKET to make `connect' return immediately without waiting for
     the response.  *Note File Status Flags::, for information about
     nonblocking mode.

     The normal return value from `connect' is `0'.  If an error
     occurs, `connect' returns `-1'.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The socket SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          File descriptor SOCKET is not a socket.

    `EADDRNOTAVAIL'
          The specified address is not available on the remote machine.

    `EAFNOSUPPORT'
          The namespace of the ADDR is not supported by this socket.

    `EISCONN'
          The socket SOCKET is already connected.

    `ETIMEDOUT'
          The attempt to establish the connection timed out.

    `ECONNREFUSED'
          The server has actively refused to establish the connection.

    `ENETUNREACH'
          The network of the given ADDR isn't reachable from this host.

    `EADDRINUSE'
          The socket address of the given ADDR is already in use.

    `EINPROGRESS'
          The socket SOCKET is non-blocking and the connection could
          not be established immediately.  You can determine when the
          connection is completely established with `select'; *note
          Waiting for I/O::.  Another `connect' call on the same
          socket, before the connection is completely established, will
          fail with `EALREADY'.

    `EALREADY'
          The socket SOCKET is non-blocking and already has a pending
          connection in progress (see `EINPROGRESS' above).

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Listening,  Next: Accepting Connections,  Prev: Connecting,  Up: Connections

16.9.2 Listening for Connections
--------------------------------

Now let us consider what the server process must do to accept
connections on a socket.  First it must use the `listen' function to
enable connection requests on the socket, and then accept each incoming
connection with a call to `accept' (*note Accepting Connections::).
Once connection requests are enabled on a server socket, the `select'
function reports when the socket has a connection ready to be accepted
(*note Waiting for I/O::).

   The `listen' function is not allowed for sockets using
connectionless communication styles.

   You can write a network server that does not even start running
until a connection to it is requested.  *Note Inetd Servers::.

   In the Internet namespace, there are no special protection mechanisms
for controlling access to a port; any process on any machine can make a
connection to your server.  If you want to restrict access to your
server, make it examine the addresses associated with connection
requests or implement some other handshaking or identification protocol.

   In the local namespace, the ordinary file protection bits control
who has access to connect to the socket.

 -- Function: int listen (int SOCKET, int N)
     The `listen' function enables the socket SOCKET to accept
     connections, thus making it a server socket.

     The argument N specifies the length of the queue for pending
     connections.  When the queue fills, new clients attempting to
     connect fail with `ECONNREFUSED' until the server calls `accept' to
     accept a connection from the queue.

     The `listen' function returns `0' on success and `-1' on failure.
     The following `errno' error conditions are defined for this
     function:

    `EBADF'
          The argument SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          The argument SOCKET is not a socket.

    `EOPNOTSUPP'
          The socket SOCKET does not support this operation.


File: libc.info,  Node: Accepting Connections,  Next: Who is Connected,  Prev: Listening,  Up: Connections

16.9.3 Accepting Connections
----------------------------

When a server receives a connection request, it can complete the
connection by accepting the request.  Use the function `accept' to do
this.

   A socket that has been established as a server can accept connection
requests from multiple clients.  The server's original socket _does not
become part of the connection_; instead, `accept' makes a new socket
which participates in the connection.  `accept' returns the descriptor
for this socket.  The server's original socket remains available for
listening for further connection requests.

   The number of pending connection requests on a server socket is
finite.  If connection requests arrive from clients faster than the
server can act upon them, the queue can fill up and additional requests
are refused with an `ECONNREFUSED' error.  You can specify the maximum
length of this queue as an argument to the `listen' function, although
the system may also impose its own internal limit on the length of this
queue.

 -- Function: int accept (int SOCKET, struct sockaddr *ADDR, socklen_t
          *LENGTH_PTR)
     This function is used to accept a connection request on the server
     socket SOCKET.

     The `accept' function waits if there are no connections pending,
     unless the socket SOCKET has nonblocking mode set.  (You can use
     `select' to wait for a pending connection, with a nonblocking
     socket.)  *Note File Status Flags::, for information about
     nonblocking mode.

     The ADDR and LENGTH-PTR arguments are used to return information
     about the name of the client socket that initiated the connection.
     *Note Socket Addresses::, for information about the format of the
     information.

     Accepting a connection does not make SOCKET part of the
     connection.  Instead, it creates a new socket which becomes
     connected.  The normal return value of `accept' is the file
     descriptor for the new socket.

     After `accept', the original socket SOCKET remains open and
     unconnected, and continues listening until you close it.  You can
     accept further connections with SOCKET by calling `accept' again.

     If an error occurs, `accept' returns `-1'.  The following `errno'
     error conditions are defined for this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET argument is not a socket.

    `EOPNOTSUPP'
          The descriptor SOCKET does not support this operation.

    `EWOULDBLOCK'
          SOCKET has nonblocking mode set, and there are no pending
          connections immediately available.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.

   The `accept' function is not allowed for sockets using
connectionless communication styles.


File: libc.info,  Node: Who is Connected,  Next: Transferring Data,  Prev: Accepting Connections,  Up: Connections

16.9.4 Who is Connected to Me?
------------------------------

 -- Function: int getpeername (int SOCKET, struct sockaddr *ADDR,
          socklen_t *LENGTH-PTR)
     The `getpeername' function returns the address of the socket that
     SOCKET is connected to; it stores the address in the memory space
     specified by ADDR and LENGTH-PTR.  It stores the length of the
     address in `*LENGTH-PTR'.

     *Note Socket Addresses::, for information about the format of the
     address.  In some operating systems, `getpeername' works only for
     sockets in the Internet domain.

     The return value is `0' on success and `-1' on error.  The
     following `errno' error conditions are defined for this function:

    `EBADF'
          The argument SOCKET is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOTCONN'
          The socket SOCKET is not connected.

    `ENOBUFS'
          There are not enough internal buffers available.


File: libc.info,  Node: Transferring Data,  Next: Byte Stream Example,  Prev: Who is Connected,  Up: Connections

16.9.5 Transferring Data
------------------------

Once a socket has been connected to a peer, you can use the ordinary
`read' and `write' operations (*note I/O Primitives::) to transfer
data.  A socket is a two-way communications channel, so read and write
operations can be performed at either end.

   There are also some I/O modes that are specific to socket operations.
In order to specify these modes, you must use the `recv' and `send'
functions instead of the more generic `read' and `write' functions.
The `recv' and `send' functions take an additional argument which you
can use to specify various flags to control special I/O modes.  For
example, you can specify the `MSG_OOB' flag to read or write
out-of-band data, the `MSG_PEEK' flag to peek at input, or the
`MSG_DONTROUTE' flag to control inclusion of routing information on
output.

* Menu:

* Sending Data::		Sending data with `send'.
* Receiving Data::		Reading data with `recv'.
* Socket Data Options::		Using `send' and `recv'.


File: libc.info,  Node: Sending Data,  Next: Receiving Data,  Up: Transferring Data

16.9.5.1 Sending Data
.....................

The `send' function is declared in the header file `sys/socket.h'.  If
your FLAGS argument is zero, you can just as well use `write' instead
of `send'; see *note I/O Primitives::.  If the socket was connected but
the connection has broken, you get a `SIGPIPE' signal for any use of
`send' or `write' (*note Miscellaneous Signals::).

 -- Function: int send (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS)
     The `send' function is like `write', but with the additional flags
     FLAGS.  The possible values of FLAGS are described in *note Socket
     Data Options::.

     This function returns the number of bytes transmitted, or `-1' on
     failure.  If the socket is nonblocking, then `send' (like `write')
     can return after sending just part of the data.  *Note File Status
     Flags::, for information about nonblocking mode.

     Note, however, that a successful return value merely indicates that
     the message has been sent without error, not necessarily that it
     has been received without error.

     The following `errno' error conditions are defined for this
     function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `EINTR'
          The operation was interrupted by a signal before any data was
          sent.  *Note Interrupted Primitives::.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `EMSGSIZE'
          The socket type requires that the message be sent atomically,
          but the message is too large for this to be possible.

    `EWOULDBLOCK'
          Nonblocking mode has been set on the socket, and the write
          operation would block.  (Normally `send' blocks until the
          operation can be completed.)

    `ENOBUFS'
          There is not enough internal buffer space available.

    `ENOTCONN'
          You never connected this socket.

    `EPIPE'
          This socket was connected but the connection is now broken.
          In this case, `send' generates a `SIGPIPE' signal first; if
          that signal is ignored or blocked, or if its handler returns,
          then `send' fails with `EPIPE'.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Receiving Data,  Next: Socket Data Options,  Prev: Sending Data,  Up: Transferring Data

16.9.5.2 Receiving Data
.......................

The `recv' function is declared in the header file `sys/socket.h'.  If
your FLAGS argument is zero, you can just as well use `read' instead of
`recv'; see *note I/O Primitives::.

 -- Function: int recv (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS)
     The `recv' function is like `read', but with the additional flags
     FLAGS.  The possible values of FLAGS are described in *note Socket
     Data Options::.

     If nonblocking mode is set for SOCKET, and no data are available to
     be read, `recv' fails immediately rather than waiting.  *Note File
     Status Flags::, for information about nonblocking mode.

     This function returns the number of bytes received, or `-1' on
     failure.  The following `errno' error conditions are defined for
     this function:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `EWOULDBLOCK'
          Nonblocking mode has been set on the socket, and the read
          operation would block.  (Normally, `recv' blocks until there
          is input available to be read.)

    `EINTR'
          The operation was interrupted by a signal before any data was
          read.  *Note Interrupted Primitives::.

    `ENOTCONN'
          You never connected this socket.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Socket Data Options,  Prev: Receiving Data,  Up: Transferring Data

16.9.5.3 Socket Data Options
............................

The FLAGS argument to `send' and `recv' is a bit mask.  You can
bitwise-OR the values of the following macros together to obtain a
value for this argument.  All are defined in the header file
`sys/socket.h'.

 -- Macro: int MSG_OOB
     Send or receive out-of-band data.  *Note Out-of-Band Data::.

 -- Macro: int MSG_PEEK
     Look at the data but don't remove it from the input queue.  This is
     only meaningful with input functions such as `recv', not with
     `send'.

 -- Macro: int MSG_DONTROUTE
     Don't include routing information in the message.  This is only
     meaningful with output operations, and is usually only of interest
     for diagnostic or routing programs.  We don't try to explain it
     here.


File: libc.info,  Node: Byte Stream Example,  Next: Server Example,  Prev: Transferring Data,  Up: Connections

16.9.6 Byte Stream Socket Example
---------------------------------

Here is an example client program that makes a connection for a byte
stream socket in the Internet namespace.  It doesn't do anything
particularly interesting once it has connected to the server; it just
sends a text string to the server and exits.

   This program uses `init_sockaddr' to set up the socket address; see
*note Inet Example::.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <netdb.h>

     #define PORT            5555
     #define MESSAGE         "Yow!!! Are we having fun yet?!?"
     #define SERVERHOST      "mescaline.gnu.org"

     void
     write_to_server (int filedes)
     {
       int nbytes;

       nbytes = write (filedes, MESSAGE, strlen (MESSAGE) + 1);
       if (nbytes < 0)
         {
           perror ("write");
           exit (EXIT_FAILURE);
         }
     }


     int
     main (void)
     {
       extern void init_sockaddr (struct sockaddr_in *name,
                                  const char *hostname,
                                  uint16_t port);
       int sock;
       struct sockaddr_in servername;

       /* Create the socket. */
       sock = socket (PF_INET, SOCK_STREAM, 0);
       if (sock < 0)
         {
           perror ("socket (client)");
           exit (EXIT_FAILURE);
         }

       /* Connect to the server. */
       init_sockaddr (&servername, SERVERHOST, PORT);
       if (0 > connect (sock,
                        (struct sockaddr *) &servername,
                        sizeof (servername)))
         {
           perror ("connect (client)");
           exit (EXIT_FAILURE);
         }

       /* Send data to the server. */
       write_to_server (sock);
       close (sock);
       exit (EXIT_SUCCESS);
     }


File: libc.info,  Node: Server Example,  Next: Out-of-Band Data,  Prev: Byte Stream Example,  Up: Connections

16.9.7 Byte Stream Connection Server Example
--------------------------------------------

The server end is much more complicated.  Since we want to allow
multiple clients to be connected to the server at the same time, it
would be incorrect to wait for input from a single client by simply
calling `read' or `recv'.  Instead, the right thing to do is to use
`select' (*note Waiting for I/O::) to wait for input on all of the open
sockets.  This also allows the server to deal with additional
connection requests.

   This particular server doesn't do anything interesting once it has
gotten a message from a client.  It does close the socket for that
client when it detects an end-of-file condition (resulting from the
client shutting down its end of the connection).

   This program uses `make_socket' to set up the socket address; see
*note Inet Example::.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/socket.h>
     #include <netinet/in.h>
     #include <netdb.h>

     #define PORT    5555
     #define MAXMSG  512

     int
     read_from_client (int filedes)
     {
       char buffer[MAXMSG];
       int nbytes;

       nbytes = read (filedes, buffer, MAXMSG);
       if (nbytes < 0)
         {
           /* Read error. */
           perror ("read");
           exit (EXIT_FAILURE);
         }
       else if (nbytes == 0)
         /* End-of-file. */
         return -1;
       else
         {
           /* Data read. */
           fprintf (stderr, "Server: got message: `%s'\n", buffer);
           return 0;
         }
     }

     int
     main (void)
     {
       extern int make_socket (uint16_t port);
       int sock;
       fd_set active_fd_set, read_fd_set;
       int i;
       struct sockaddr_in clientname;
       size_t size;

       /* Create the socket and set it up to accept connections. */
       sock = make_socket (PORT);
       if (listen (sock, 1) < 0)
         {
           perror ("listen");
           exit (EXIT_FAILURE);
         }

       /* Initialize the set of active sockets. */
       FD_ZERO (&active_fd_set);
       FD_SET (sock, &active_fd_set);

       while (1)
         {
           /* Block until input arrives on one or more active sockets. */
           read_fd_set = active_fd_set;
           if (select (FD_SETSIZE, &read_fd_set, NULL, NULL, NULL) < 0)
             {
               perror ("select");
               exit (EXIT_FAILURE);
             }

           /* Service all the sockets with input pending. */
           for (i = 0; i < FD_SETSIZE; ++i)
             if (FD_ISSET (i, &read_fd_set))
               {
                 if (i == sock)
                   {
                     /* Connection request on original socket. */
                     int new;
                     size = sizeof (clientname);
                     new = accept (sock,
                                   (struct sockaddr *) &clientname,
                                   &size);
                     if (new < 0)
                       {
                         perror ("accept");
                         exit (EXIT_FAILURE);
                       }
                     fprintf (stderr,
                              "Server: connect from host %s, port %hd.\n",
                              inet_ntoa (clientname.sin_addr),
                              ntohs (clientname.sin_port));
                     FD_SET (new, &active_fd_set);
                   }
                 else
                   {
                     /* Data arriving on an already-connected socket. */
                     if (read_from_client (i) < 0)
                       {
                         close (i);
                         FD_CLR (i, &active_fd_set);
                       }
                   }
               }
         }
     }


File: libc.info,  Node: Out-of-Band Data,  Prev: Server Example,  Up: Connections

16.9.8 Out-of-Band Data
-----------------------

Streams with connections permit "out-of-band" data that is delivered
with higher priority than ordinary data.  Typically the reason for
sending out-of-band data is to send notice of an exceptional condition.
To send out-of-band data use `send', specifying the flag `MSG_OOB'
(*note Sending Data::).

   Out-of-band data are received with higher priority because the
receiving process need not read it in sequence; to read the next
available out-of-band data, use `recv' with the `MSG_OOB' flag (*note
Receiving Data::).  Ordinary read operations do not read out-of-band
data; they read only ordinary data.

   When a socket finds that out-of-band data are on their way, it sends
a `SIGURG' signal to the owner process or process group of the socket.
You can specify the owner using the `F_SETOWN' command to the `fcntl'
function; see *note Interrupt Input::.  You must also establish a
handler for this signal, as described in *note Signal Handling::, in
order to take appropriate action such as reading the out-of-band data.

   Alternatively, you can test for pending out-of-band data, or wait
until there is out-of-band data, using the `select' function; it can
wait for an exceptional condition on the socket.  *Note Waiting for
I/O::, for more information about `select'.

   Notification of out-of-band data (whether with `SIGURG' or with
`select') indicates that out-of-band data are on the way; the data may
not actually arrive until later.  If you try to read the out-of-band
data before it arrives, `recv' fails with an `EWOULDBLOCK' error.

   Sending out-of-band data automatically places a "mark" in the stream
of ordinary data, showing where in the sequence the out-of-band data
"would have been".  This is useful when the meaning of out-of-band data
is "cancel everything sent so far".  Here is how you can test, in the
receiving process, whether any ordinary data was sent before the mark:

     success = ioctl (socket, SIOCATMARK, &atmark);

   The `integer' variable ATMARK is set to a nonzero value if the
socket's read pointer has reached the "mark".

   Here's a function to discard any ordinary data preceding the
out-of-band mark:

     int
     discard_until_mark (int socket)
     {
       while (1)
         {
           /* This is not an arbitrary limit; any size will do.  */
           char buffer[1024];
           int atmark, success;

           /* If we have reached the mark, return.  */
           success = ioctl (socket, SIOCATMARK, &atmark);
           if (success < 0)
             perror ("ioctl");
           if (result)
             return;

           /* Otherwise, read a bunch of ordinary data and discard it.
              This is guaranteed not to read past the mark
              if it starts before the mark.  */
           success = read (socket, buffer, sizeof buffer);
           if (success < 0)
             perror ("read");
         }
     }

   If you don't want to discard the ordinary data preceding the mark,
you may need to read some of it anyway, to make room in internal system
buffers for the out-of-band data.  If you try to read out-of-band data
and get an `EWOULDBLOCK' error, try reading some ordinary data (saving
it so that you can use it when you want it) and see if that makes room.
Here is an example:

     struct buffer
     {
       char *buf;
       int size;
       struct buffer *next;
     };

     /* Read the out-of-band data from SOCKET and return it
        as a `struct buffer', which records the address of the data
        and its size.

        It may be necessary to read some ordinary data
        in order to make room for the out-of-band data.
        If so, the ordinary data are saved as a chain of buffers
        found in the `next' field of the value.  */

     struct buffer *
     read_oob (int socket)
     {
       struct buffer *tail = 0;
       struct buffer *list = 0;

       while (1)
         {
           /* This is an arbitrary limit.
              Does anyone know how to do this without a limit?  */
     #define BUF_SZ 1024
           char *buf = (char *) xmalloc (BUF_SZ);
           int success;
           int atmark;

           /* Try again to read the out-of-band data.  */
           success = recv (socket, buf, BUF_SZ, MSG_OOB);
           if (success >= 0)
             {
               /* We got it, so return it.  */
               struct buffer *link
                 = (struct buffer *) xmalloc (sizeof (struct buffer));
               link->buf = buf;
               link->size = success;
               link->next = list;
               return link;
             }

           /* If we fail, see if we are at the mark.  */
           success = ioctl (socket, SIOCATMARK, &atmark);
           if (success < 0)
             perror ("ioctl");
           if (atmark)
             {
               /* At the mark; skipping past more ordinary data cannot help.
                  So just wait a while.  */
               sleep (1);
               continue;
             }

           /* Otherwise, read a bunch of ordinary data and save it.
              This is guaranteed not to read past the mark
              if it starts before the mark.  */
           success = read (socket, buf, BUF_SZ);
           if (success < 0)
             perror ("read");

           /* Save this data in the buffer list.  */
           {
             struct buffer *link
               = (struct buffer *) xmalloc (sizeof (struct buffer));
             link->buf = buf;
             link->size = success;

             /* Add the new link to the end of the list.  */
             if (tail)
               tail->next = link;
             else
               list = link;
             tail = link;
           }
         }
     }


File: libc.info,  Node: Datagrams,  Next: Inetd,  Prev: Connections,  Up: Sockets

16.10 Datagram Socket Operations
================================

This section describes how to use communication styles that don't use
connections (styles `SOCK_DGRAM' and `SOCK_RDM').  Using these styles,
you group data into packets and each packet is an independent
communication.  You specify the destination for each packet
individually.

   Datagram packets are like letters: you send each one independently
with its own destination address, and they may arrive in the wrong
order or not at all.

   The `listen' and `accept' functions are not allowed for sockets
using connectionless communication styles.

* Menu:

* Sending Datagrams::    Sending packets on a datagram socket.
* Receiving Datagrams::  Receiving packets on a datagram socket.
* Datagram Example::     An example program: packets sent over a
                           datagram socket in the local namespace.
* Example Receiver::	 Another program, that receives those packets.


File: libc.info,  Node: Sending Datagrams,  Next: Receiving Datagrams,  Up: Datagrams

16.10.1 Sending Datagrams
-------------------------

The normal way of sending data on a datagram socket is by using the
`sendto' function, declared in `sys/socket.h'.

   You can call `connect' on a datagram socket, but this only specifies
a default destination for further data transmission on the socket.
When a socket has a default destination you can use `send' (*note
Sending Data::) or even `write' (*note I/O Primitives::) to send a
packet there.  You can cancel the default destination by calling
`connect' using an address format of `AF_UNSPEC' in the ADDR argument.
*Note Connecting::, for more information about the `connect' function.

 -- Function: int sendto (int SOCKET, void *BUFFER. size_t SIZE, int
          FLAGS, struct sockaddr *ADDR, socklen_t LENGTH)
     The `sendto' function transmits the data in the BUFFER through the
     socket SOCKET to the destination address specified by the ADDR and
     LENGTH arguments.  The SIZE argument specifies the number of bytes
     to be transmitted.

     The FLAGS are interpreted the same way as for `send'; see *note
     Socket Data Options::.

     The return value and error conditions are also the same as for
     `send', but you cannot rely on the system to detect errors and
     report them; the most common error is that the packet is lost or
     there is no-one at the specified address to receive it, and the
     operating system on your machine usually does not know this.

     It is also possible for one call to `sendto' to report an error
     owing to a problem related to a previous call.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.


File: libc.info,  Node: Receiving Datagrams,  Next: Datagram Example,  Prev: Sending Datagrams,  Up: Datagrams

16.10.2 Receiving Datagrams
---------------------------

The `recvfrom' function reads a packet from a datagram socket and also
tells you where it was sent from.  This function is declared in
`sys/socket.h'.

 -- Function: int recvfrom (int SOCKET, void *BUFFER, size_t SIZE, int
          FLAGS, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)
     The `recvfrom' function reads one packet from the socket SOCKET
     into the buffer BUFFER.  The SIZE argument specifies the maximum
     number of bytes to be read.

     If the packet is longer than SIZE bytes, then you get the first
     SIZE bytes of the packet and the rest of the packet is lost.
     There's no way to read the rest of the packet.  Thus, when you use
     a packet protocol, you must always know how long a packet to
     expect.

     The ADDR and LENGTH-PTR arguments are used to return the address
     where the packet came from.  *Note Socket Addresses::.  For a
     socket in the local domain the address information won't be
     meaningful, since you can't read the address of such a socket
     (*note Local Namespace::).  You can specify a null pointer as the
     ADDR argument if you are not interested in this information.

     The FLAGS are interpreted the same way as for `recv' (*note Socket
     Data Options::).  The return value and error conditions are also
     the same as for `recv'.

     This function is defined as a cancellation point in multi-threaded
     programs, so one has to be prepared for this and make sure that
     allocated resources (like memory, files descriptors, semaphores or
     whatever) are freed even if the thread is canceled.

   You can use plain `recv' (*note Receiving Data::) instead of
`recvfrom' if you don't need to find out who sent the packet (either
because you know where it should come from or because you treat all
possible senders alike).  Even `read' can be used if you don't want to
specify FLAGS (*note I/O Primitives::).


File: libc.info,  Node: Datagram Example,  Next: Example Receiver,  Prev: Receiving Datagrams,  Up: Datagrams

16.10.3 Datagram Socket Example
-------------------------------

Here is a set of example programs that send messages over a datagram
stream in the local namespace.  Both the client and server programs use
the `make_named_socket' function that was presented in *note Local
Socket Example::, to create and name their sockets.

   First, here is the server program.  It sits in a loop waiting for
messages to arrive, bouncing each message back to the sender.
Obviously this isn't a particularly useful program, but it does show
the general ideas involved.

     #include <stdio.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <sys/un.h>

     #define SERVER  "/tmp/serversocket"
     #define MAXMSG  512

     int
     main (void)
     {
       int sock;
       char message[MAXMSG];
       struct sockaddr_un name;
       size_t size;
       int nbytes;

       /* Remove the filename first, it's ok if the call fails */
       unlink (SERVER);

       /* Make the socket, then loop endlessly. */
       sock = make_named_socket (SERVER);
       while (1)
         {
           /* Wait for a datagram. */
           size = sizeof (name);
           nbytes = recvfrom (sock, message, MAXMSG, 0,
                              (struct sockaddr *) & name, &size);
           if (nbytes < 0)
             {
               perror ("recfrom (server)");
               exit (EXIT_FAILURE);
             }

           /* Give a diagnostic message. */
           fprintf (stderr, "Server: got message: %s\n", message);

           /* Bounce the message back to the sender. */
           nbytes = sendto (sock, message, nbytes, 0,
                            (struct sockaddr *) & name, size);
           if (nbytes < 0)
             {
               perror ("sendto (server)");
               exit (EXIT_FAILURE);
             }
         }
     }


File: libc.info,  Node: Example Receiver,  Prev: Datagram Example,  Up: Datagrams

16.10.4 Example of Reading Datagrams
------------------------------------

Here is the client program corresponding to the server above.

   It sends a datagram to the server and then waits for a reply.  Notice
that the socket for the client (as well as for the server) in this
example has to be given a name.  This is so that the server can direct
a message back to the client.  Since the socket has no associated
connection state, the only way the server can do this is by referencing
the name of the client.

     #include <stdio.h>
     #include <errno.h>
     #include <unistd.h>
     #include <stdlib.h>
     #include <sys/socket.h>
     #include <sys/un.h>

     #define SERVER  "/tmp/serversocket"
     #define CLIENT  "/tmp/mysocket"
     #define MAXMSG  512
     #define MESSAGE "Yow!!! Are we having fun yet?!?"

     int
     main (void)
     {
       extern int make_named_socket (const char *name);
       int sock;
       char message[MAXMSG];
       struct sockaddr_un name;
       size_t size;
       int nbytes;

       /* Make the socket. */
       sock = make_named_socket (CLIENT);

       /* Initialize the server socket address. */
       name.sun_family = AF_LOCAL;
       strcpy (name.sun_path, SERVER);
       size = strlen (name.sun_path) + sizeof (name.sun_family);

       /* Send the datagram. */
       nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,
                        (struct sockaddr *) & name, size);
       if (nbytes < 0)
         {
           perror ("sendto (client)");
           exit (EXIT_FAILURE);
         }

       /* Wait for a reply. */
       nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);
       if (nbytes < 0)
         {
           perror ("recfrom (client)");
           exit (EXIT_FAILURE);
         }

       /* Print a diagnostic message. */
       fprintf (stderr, "Client: got message: %s\n", message);

       /* Clean up. */
       remove (CLIENT);
       close (sock);
     }

   Keep in mind that datagram socket communications are unreliable.  In
this example, the client program waits indefinitely if the message
never reaches the server or if the server's response never comes back.
It's up to the user running the program to kill and restart it if
desired.  A more automatic solution could be to use `select' (*note
Waiting for I/O::) to establish a timeout period for the reply, and in
case of timeout either re-send the message or shut down the socket and
exit.


File: libc.info,  Node: Inetd,  Next: Socket Options,  Prev: Datagrams,  Up: Sockets

16.11 The `inetd' Daemon
========================

We've explained above how to write a server program that does its own
listening.  Such a server must already be running in order for anyone
to connect to it.

   Another way to provide a service on an Internet port is to let the
daemon program `inetd' do the listening.  `inetd' is a program that
runs all the time and waits (using `select') for messages on a
specified set of ports.  When it receives a message, it accepts the
connection (if the socket style calls for connections) and then forks a
child process to run the corresponding server program.  You specify the
ports and their programs in the file `/etc/inetd.conf'.

* Menu:

* Inetd Servers::
* Configuring Inetd::


File: libc.info,  Node: Inetd Servers,  Next: Configuring Inetd,  Up: Inetd

16.11.1 `inetd' Servers
-----------------------

Writing a server program to be run by `inetd' is very simple.  Each time
someone requests a connection to the appropriate port, a new server
process starts.  The connection already exists at this time; the socket
is available as the standard input descriptor and as the standard
output descriptor (descriptors 0 and 1) in the server process.  Thus
the server program can begin reading and writing data right away.
Often the program needs only the ordinary I/O facilities; in fact, a
general-purpose filter program that knows nothing about sockets can
work as a byte stream server run by `inetd'.

   You can also use `inetd' for servers that use connectionless
communication styles.  For these servers, `inetd' does not try to accept
a connection since no connection is possible.  It just starts the
server program, which can read the incoming datagram packet from
descriptor 0.  The server program can handle one request and then exit,
or you can choose to write it to keep reading more requests until no
more arrive, and then exit.  You must specify which of these two
techniques the server uses when you configure `inetd'.


File: libc.info,  Node: Configuring Inetd,  Prev: Inetd Servers,  Up: Inetd

16.11.2 Configuring `inetd'
---------------------------

The file `/etc/inetd.conf' tells `inetd' which ports to listen to and
what server programs to run for them.  Normally each entry in the file
is one line, but you can split it onto multiple lines provided all but
the first line of the entry start with whitespace.  Lines that start
with `#' are comments.

   Here are two standard entries in `/etc/inetd.conf':

     ftp	stream	tcp	nowait	root	/libexec/ftpd	ftpd
     talk	dgram	udp	wait	root	/libexec/talkd	talkd

   An entry has this format:

     SERVICE STYLE PROTOCOL WAIT USERNAME PROGRAM ARGUMENTS

   The SERVICE field says which service this program provides.  It
should be the name of a service defined in `/etc/services'.  `inetd'
uses SERVICE to decide which port to listen on for this entry.

   The fields STYLE and PROTOCOL specify the communication style and
the protocol to use for the listening socket.  The style should be the
name of a communication style, converted to lower case and with `SOCK_'
deleted--for example, `stream' or `dgram'.  PROTOCOL should be one of
the protocols listed in `/etc/protocols'.  The typical protocol names
are `tcp' for byte stream connections and `udp' for unreliable
datagrams.

   The WAIT field should be either `wait' or `nowait'.  Use `wait' if
STYLE is a connectionless style and the server, once started, handles
multiple requests as they come in.  Use `nowait' if `inetd' should
start a new process for each message or request that comes in.  If
STYLE uses connections, then WAIT *must* be `nowait'.

   USER is the user name that the server should run as.  `inetd' runs
as root, so it can set the user ID of its children arbitrarily.  It's
best to avoid using `root' for USER if you can; but some servers, such
as Telnet and FTP, read a username and password themselves.  These
servers need to be root initially so they can log in as commanded by
the data coming over the network.

   PROGRAM together with ARGUMENTS specifies the command to run to
start the server.  PROGRAM should be an absolute file name specifying
the executable file to run.  ARGUMENTS consists of any number of
whitespace-separated words, which become the command-line arguments of
PROGRAM.  The first word in ARGUMENTS is argument zero, which should by
convention be the program name itself (sans directories).

   If you edit `/etc/inetd.conf', you can tell `inetd' to reread the
file and obey its new contents by sending the `inetd' process the
`SIGHUP' signal.  You'll have to use `ps' to determine the process ID
of the `inetd' process as it is not fixed.


File: libc.info,  Node: Socket Options,  Next: Networks Database,  Prev: Inetd,  Up: Sockets

16.12 Socket Options
====================

This section describes how to read or set various options that modify
the behavior of sockets and their underlying communications protocols.

   When you are manipulating a socket option, you must specify which
"level" the option pertains to.  This describes whether the option
applies to the socket interface, or to a lower-level communications
protocol interface.

* Menu:

* Socket Option Functions::     The basic functions for setting and getting
                                 socket options.
* Socket-Level Options::        Details of the options at the socket level.


File: libc.info,  Node: Socket Option Functions,  Next: Socket-Level Options,  Up: Socket Options

16.12.1 Socket Option Functions
-------------------------------

Here are the functions for examining and modifying socket options.
They are declared in `sys/socket.h'.

 -- Function: int getsockopt (int SOCKET, int LEVEL, int OPTNAME, void
          *OPTVAL, socklen_t *OPTLEN-PTR)
     The `getsockopt' function gets information about the value of
     option OPTNAME at level LEVEL for socket SOCKET.

     The option value is stored in a buffer that OPTVAL points to.
     Before the call, you should supply in `*OPTLEN-PTR' the size of
     this buffer; on return, it contains the number of bytes of
     information actually stored in the buffer.

     Most options interpret the OPTVAL buffer as a single `int' value.

     The actual return value of `getsockopt' is `0' on success and `-1'
     on failure.  The following `errno' error conditions are defined:

    `EBADF'
          The SOCKET argument is not a valid file descriptor.

    `ENOTSOCK'
          The descriptor SOCKET is not a socket.

    `ENOPROTOOPT'
          The OPTNAME doesn't make sense for the given LEVEL.

 -- Function: int setsockopt (int SOCKET, int LEVEL, int OPTNAME, void
          *OPTVAL, socklen_t OPTLEN)
     This function is used to set the socket option OPTNAME at level
     LEVEL for socket SOCKET.  The value of the option is passed in the
     buffer OPTVAL of size OPTLEN.

     The return value and error codes for `setsockopt' are the same as
     for `getsockopt'.



File: libc.info,  Node: Socket-Level Options,  Prev: Socket Option Functions,  Up: Socket Options

16.12.2 Socket-Level Options
----------------------------

 -- Constant: int SOL_SOCKET
     Use this constant as the LEVEL argument to `getsockopt' or
     `setsockopt' to manipulate the socket-level options described in
     this section.

Here is a table of socket-level option names; all are defined in the
header file `sys/socket.h'.

`SO_DEBUG'
     This option toggles recording of debugging information in the
     underlying protocol modules.  The value has type `int'; a nonzero
     value means "yes".

`SO_REUSEADDR'
     This option controls whether `bind' (*note Setting Address::)
     should permit reuse of local addresses for this socket.  If you
     enable this option, you can actually have two sockets with the
     same Internet port number; but the system won't allow you to use
     the two identically-named sockets in a way that would confuse the
     Internet.  The reason for this option is that some higher-level
     Internet protocols, including FTP, require you to keep reusing the
     same port number.

     The value has type `int'; a nonzero value means "yes".

`SO_KEEPALIVE'
     This option controls whether the underlying protocol should
     periodically transmit messages on a connected socket.  If the peer
     fails to respond to these messages, the connection is considered
     broken.  The value has type `int'; a nonzero value means "yes".

`SO_DONTROUTE'
     This option controls whether outgoing messages bypass the normal
     message routing facilities.  If set, messages are sent directly to
     the network interface instead.  The value has type `int'; a nonzero
     value means "yes".

`SO_LINGER'
     This option specifies what should happen when the socket of a type
     that promises reliable delivery still has untransmitted messages
     when it is closed; see *note Closing a Socket::.  The value has
     type `struct linger'.

      -- Data Type: struct linger
          This structure type has the following members:

         `int l_onoff'
               This field is interpreted as a boolean.  If nonzero,
               `close' blocks until the data are transmitted or the
               timeout period has expired.

         `int l_linger'
               This specifies the timeout period, in seconds.

`SO_BROADCAST'
     This option controls whether datagrams may be broadcast from the
     socket.  The value has type `int'; a nonzero value means "yes".

`SO_OOBINLINE'
     If this option is set, out-of-band data received on the socket is
     placed in the normal input queue.  This permits it to be read using
     `read' or `recv' without specifying the `MSG_OOB' flag.  *Note
     Out-of-Band Data::.  The value has type `int'; a nonzero value
     means "yes".

`SO_SNDBUF'
     This option gets or sets the size of the output buffer.  The value
     is a `size_t', which is the size in bytes.

`SO_RCVBUF'
     This option gets or sets the size of the input buffer.  The value
     is a `size_t', which is the size in bytes.

`SO_STYLE'
`SO_TYPE'
     This option can be used with `getsockopt' only.  It is used to get
     the socket's communication style.  `SO_TYPE' is the historical
     name, and `SO_STYLE' is the preferred name in GNU.  The value has
     type `int' and its value designates a communication style; see
     *note Communication Styles::.

`SO_ERROR'
     This option can be used with `getsockopt' only.  It is used to
     reset the error status of the socket.  The value is an `int',
     which represents the previous error status.


File: libc.info,  Node: Networks Database,  Prev: Socket Options,  Up: Sockets

16.13 Networks Database
=======================

Many systems come with a database that records a list of networks known
to the system developer.  This is usually kept either in the file
`/etc/networks' or in an equivalent from a name server.  This data base
is useful for routing programs such as `route', but it is not useful
for programs that simply communicate over the network.  We provide
functions to access this database, which are declared in `netdb.h'.

 -- Data Type: struct netent
     This data type is used to represent information about entries in
     the networks database.  It has the following members:

    `char *n_name'
          This is the "official" name of the network.

    `char **n_aliases'
          These are alternative names for the network, represented as a
          vector of strings.  A null pointer terminates the array.

    `int n_addrtype'
          This is the type of the network number; this is always equal
          to `AF_INET' for Internet networks.

    `unsigned long int n_net'
          This is the network number.  Network numbers are returned in
          host byte order; see *note Byte Order::.

   Use the `getnetbyname' or `getnetbyaddr' functions to search the
networks database for information about a specific network.  The
information is returned in a statically-allocated structure; you must
copy the information if you need to save it.

 -- Function: struct netent * getnetbyname (const char *NAME)
     The `getnetbyname' function returns information about the network
     named NAME.  It returns a null pointer if there is no such network.

 -- Function: struct netent * getnetbyaddr (unsigned long int NET, int
          TYPE)
     The `getnetbyaddr' function returns information about the network
     of type TYPE with number NET.  You should specify a value of
     `AF_INET' for the TYPE argument for Internet networks.

     `getnetbyaddr' returns a null pointer if there is no such network.

   You can also scan the networks database using `setnetent',
`getnetent' and `endnetent'.  Be careful when using these functions
because they are not reentrant.

 -- Function: void setnetent (int STAYOPEN)
     This function opens and rewinds the networks database.

     If the STAYOPEN argument is nonzero, this sets a flag so that
     subsequent calls to `getnetbyname' or `getnetbyaddr' will not
     close the database (as they usually would).  This makes for more
     efficiency if you call those functions several times, by avoiding
     reopening the database for each call.

 -- Function: struct netent * getnetent (void)
     This function returns the next entry in the networks database.  It
     returns a null pointer if there are no more entries.

 -- Function: void endnetent (void)
     This function closes the networks database.


File: libc.info,  Node: Low-Level Terminal Interface,  Next: Syslog,  Prev: Sockets,  Up: Top

17 Low-Level Terminal Interface
*******************************

This chapter describes functions that are specific to terminal devices.
You can use these functions to do things like turn off input echoing;
set serial line characteristics such as line speed and flow control; and
change which characters are used for end-of-file, command-line editing,
sending signals, and similar control functions.

   Most of the functions in this chapter operate on file descriptors.
*Note Low-Level I/O::, for more information about what a file
descriptor is and how to open a file descriptor for a terminal device.

* Menu:

* Is It a Terminal::            How to determine if a file is a terminal
			         device, and what its name is.
* I/O Queues::                  About flow control and typeahead.
* Canonical or Not::            Two basic styles of input processing.
* Terminal Modes::              How to examine and modify flags controlling
			         details of terminal I/O: echoing,
                                 signals, editing.  Posix.
* BSD Terminal Modes::          BSD compatible terminal mode setting
* Line Control::                Sending break sequences, clearing
                                 terminal buffers ...
* Noncanon Example::            How to read single characters without echo.
* Pseudo-Terminals::            How to open a pseudo-terminal.


File: libc.info,  Node: Is It a Terminal,  Next: I/O Queues,  Up: Low-Level Terminal Interface

17.1 Identifying Terminals
==========================

The functions described in this chapter only work on files that
correspond to terminal devices.  You can find out whether a file
descriptor is associated with a terminal by using the `isatty' function.

   Prototypes for the functions in this section are declared in the
header file `unistd.h'.

 -- Function: int isatty (int FILEDES)
     This function returns `1' if FILEDES is a file descriptor
     associated with an open terminal device, and 0 otherwise.

   If a file descriptor is associated with a terminal, you can get its
associated file name using the `ttyname' function.  See also the
`ctermid' function, described in *note Identifying the Terminal::.

 -- Function: char * ttyname (int FILEDES)
     If the file descriptor FILEDES is associated with a terminal
     device, the `ttyname' function returns a pointer to a
     statically-allocated, null-terminated string containing the file
     name of the terminal file.  The value is a null pointer if the
     file descriptor isn't associated with a terminal, or the file name
     cannot be determined.

 -- Function: int ttyname_r (int FILEDES, char *BUF, size_t LEN)
     The `ttyname_r' function is similar to the `ttyname' function
     except that it places its result into the user-specified buffer
     starting at BUF with length LEN.

     The normal return value from `ttyname_r' is 0.  Otherwise an error
     number is returned to indicate the error.  The following `errno'
     error conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

    `ERANGE'
          The buffer length LEN is too small to store the string to be
          returned.


File: libc.info,  Node: I/O Queues,  Next: Canonical or Not,  Prev: Is It a Terminal,  Up: Low-Level Terminal Interface

17.2 I/O Queues
===============

Many of the remaining functions in this section refer to the input and
output queues of a terminal device.  These queues implement a form of
buffering _within the kernel_ independent of the buffering implemented
by I/O streams (*note I/O on Streams::).

   The "terminal input queue" is also sometimes referred to as its
"typeahead buffer".  It holds the characters that have been received
from the terminal but not yet read by any process.

   The size of the input queue is described by the `MAX_INPUT' and
`_POSIX_MAX_INPUT' parameters; see *note Limits for Files::.  You are
guaranteed a queue size of at least `MAX_INPUT', but the queue might be
larger, and might even dynamically change size.  If input flow control
is enabled by setting the `IXOFF' input mode bit (*note Input Modes::),
the terminal driver transmits STOP and START characters to the terminal
when necessary to prevent the queue from overflowing.  Otherwise, input
may be lost if it comes in too fast from the terminal.  In canonical
mode, all input stays in the queue until a newline character is
received, so the terminal input queue can fill up when you type a very
long line.  *Note Canonical or Not::.

   The "terminal output queue" is like the input queue, but for output;
it contains characters that have been written by processes, but not yet
transmitted to the terminal.  If output flow control is enabled by
setting the `IXON' input mode bit (*note Input Modes::), the terminal
driver obeys START and STOP characters sent by the terminal to stop and
restart transmission of output.

   "Clearing" the terminal input queue means discarding any characters
that have been received but not yet read.  Similarly, clearing the
terminal output queue means discarding any characters that have been
written but not yet transmitted.


File: libc.info,  Node: Canonical or Not,  Next: Terminal Modes,  Prev: I/O Queues,  Up: Low-Level Terminal Interface

17.3 Two Styles of Input: Canonical or Not
==========================================

POSIX systems support two basic modes of input: canonical and
noncanonical.

   In "canonical input processing" mode, terminal input is processed in
lines terminated by newline (`'\n''), EOF, or EOL characters.  No input
can be read until an entire line has been typed by the user, and the
`read' function (*note I/O Primitives::) returns at most a single line
of input, no matter how many bytes are requested.

   In canonical input mode, the operating system provides input editing
facilities: some characters are interpreted specially to perform editing
operations within the current line of text, such as ERASE and KILL.
*Note Editing Characters::.

   The constants `_POSIX_MAX_CANON' and `MAX_CANON' parameterize the
maximum number of bytes which may appear in a single line of canonical
input.  *Note Limits for Files::.  You are guaranteed a maximum line
length of at least `MAX_CANON' bytes, but the maximum might be larger,
and might even dynamically change size.

   In "noncanonical input processing" mode, characters are not grouped
into lines, and ERASE and KILL processing is not performed.  The
granularity with which bytes are read in noncanonical input mode is
controlled by the MIN and TIME settings.  *Note Noncanonical Input::.

   Most programs use canonical input mode, because this gives the user a
way to edit input line by line.  The usual reason to use noncanonical
mode is when the program accepts single-character commands or provides
its own editing facilities.

   The choice of canonical or noncanonical input is controlled by the
`ICANON' flag in the `c_lflag' member of `struct termios'.  *Note Local
Modes::.


File: libc.info,  Node: Terminal Modes,  Next: BSD Terminal Modes,  Prev: Canonical or Not,  Up: Low-Level Terminal Interface

17.4 Terminal Modes
===================

This section describes the various terminal attributes that control how
input and output are done.  The functions, data structures, and symbolic
constants are all declared in the header file `termios.h'.

   Don't confuse terminal attributes with file attributes.  A device
special file which is associated with a terminal has file attributes as
described in *note File Attributes::.  These are unrelated to the
attributes of the terminal device itself, which are discussed in this
section.

* Menu:

* Mode Data Types::             The data type `struct termios' and
                                 related types.
* Mode Functions::              Functions to read and set the terminal
                                 attributes.
* Setting Modes::               The right way to set terminal attributes
                                 reliably.
* Input Modes::                 Flags controlling low-level input handling.
* Output Modes::                Flags controlling low-level output handling.
* Control Modes::               Flags controlling serial port behavior.
* Local Modes::                 Flags controlling high-level input handling.
* Line Speed::                  How to read and set the terminal line speed.
* Special Characters::          Characters that have special effects,
			         and how to change them.
* Noncanonical Input::          Controlling how long to wait for input.


File: libc.info,  Node: Mode Data Types,  Next: Mode Functions,  Up: Terminal Modes

17.4.1 Terminal Mode Data Types
-------------------------------

The entire collection of attributes of a terminal is stored in a
structure of type `struct termios'.  This structure is used with the
functions `tcgetattr' and `tcsetattr' to read and set the attributes.

 -- Data Type: struct termios
     Structure that records all the I/O attributes of a terminal.  The
     structure includes at least the following members:

    `tcflag_t c_iflag'
          A bit mask specifying flags for input modes; see *note Input
          Modes::.

    `tcflag_t c_oflag'
          A bit mask specifying flags for output modes; see *note
          Output Modes::.

    `tcflag_t c_cflag'
          A bit mask specifying flags for control modes; see *note
          Control Modes::.

    `tcflag_t c_lflag'
          A bit mask specifying flags for local modes; see *note Local
          Modes::.

    `cc_t c_cc[NCCS]'
          An array specifying which characters are associated with
          various control functions; see *note Special Characters::.

     The `struct termios' structure also contains members which encode
     input and output transmission speeds, but the representation is
     not specified.  *Note Line Speed::, for how to examine and store
     the speed values.

   The following sections describe the details of the members of the
`struct termios' structure.

 -- Data Type: tcflag_t
     This is an unsigned integer type used to represent the various bit
     masks for terminal flags.

 -- Data Type: cc_t
     This is an unsigned integer type used to represent characters
     associated with various terminal control functions.

 -- Macro: int NCCS
     The value of this macro is the number of elements in the `c_cc'
     array.


File: libc.info,  Node: Mode Functions,  Next: Setting Modes,  Prev: Mode Data Types,  Up: Terminal Modes

17.4.2 Terminal Mode Functions
------------------------------

 -- Function: int tcgetattr (int FILEDES, struct termios *TERMIOS-P)
     This function is used to examine the attributes of the terminal
     device with file descriptor FILEDES.  The attributes are returned
     in the structure that TERMIOS-P points to.

     If successful, `tcgetattr' returns 0.  A return value of -1
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

 -- Function: int tcsetattr (int FILEDES, int WHEN, const struct
          termios *TERMIOS-P)
     This function sets the attributes of the terminal device with file
     descriptor FILEDES.  The new attributes are taken from the
     structure that TERMIOS-P points to.

     The WHEN argument specifies how to deal with input and output
     already queued.  It can be one of the following values:

    `TCSANOW'
          Make the change immediately.

    `TCSADRAIN'
          Make the change after waiting until all queued output has
          been written.  You should usually use this option when
          changing parameters that affect output.

    `TCSAFLUSH'
          This is like `TCSADRAIN', but also discards any queued input.

    `TCSASOFT'
          This is a flag bit that you can add to any of the above
          alternatives.  Its meaning is to inhibit alteration of the
          state of the terminal hardware.  It is a BSD extension; it is
          only supported on BSD systems and the GNU system.

          Using `TCSASOFT' is exactly the same as setting the `CIGNORE'
          bit in the `c_cflag' member of the structure TERMIOS-P points
          to.  *Note Control Modes::, for a description of `CIGNORE'.

     If this function is called from a background process on its
     controlling terminal, normally all processes in the process group
     are sent a `SIGTTOU' signal, in the same way as if the process
     were trying to write to the terminal.  The exception is if the
     calling process itself is ignoring or blocking `SIGTTOU' signals,
     in which case the operation is performed and no signal is sent.
     *Note Job Control::.

     If successful, `tcsetattr' returns 0.  A return value of -1
     indicates an error.  The following `errno' error conditions are
     defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal.

    `EINVAL'
          Either the value of the `when' argument is not valid, or
          there is something wrong with the data in the TERMIOS-P
          argument.

Although `tcgetattr' and `tcsetattr' specify the terminal device with a
file descriptor, the attributes are those of the terminal device itself
and not of the file descriptor.  This means that the effects of
changing terminal attributes are persistent; if another process opens
the terminal file later on, it will see the changed attributes even
though it doesn't have anything to do with the open file descriptor you
originally specified in changing the attributes.

   Similarly, if a single process has multiple or duplicated file
descriptors for the same terminal device, changing the terminal
attributes affects input and output to all of these file descriptors.
This means, for example, that you can't open one file descriptor or
stream to read from a terminal in the normal line-buffered, echoed
mode; and simultaneously have another file descriptor for the same
terminal that you use to read from it in single-character, non-echoed
mode.  Instead, you have to explicitly switch the terminal back and
forth between the two modes.


File: libc.info,  Node: Setting Modes,  Next: Input Modes,  Prev: Mode Functions,  Up: Terminal Modes

17.4.3 Setting Terminal Modes Properly
--------------------------------------

When you set terminal modes, you should call `tcgetattr' first to get
the current modes of the particular terminal device, modify only those
modes that you are really interested in, and store the result with
`tcsetattr'.

   It's a bad idea to simply initialize a `struct termios' structure to
a chosen set of attributes and pass it directly to `tcsetattr'.  Your
program may be run years from now, on systems that support members not
documented in this manual.  The way to avoid setting these members to
unreasonable values is to avoid changing them.

   What's more, different terminal devices may require different mode
settings in order to function properly.  So you should avoid blindly
copying attributes from one terminal device to another.

   When a member contains a collection of independent flags, as the
`c_iflag', `c_oflag' and `c_cflag' members do, even setting the entire
member is a bad idea, because particular operating systems have their
own flags.  Instead, you should start with the current value of the
member and alter only the flags whose values matter in your program,
leaving any other flags unchanged.

   Here is an example of how to set one flag (`ISTRIP') in the `struct
termios' structure while properly preserving all the other data in the
structure:

     int
     set_istrip (int desc, int value)
     {
       struct termios settings;
       int result;

       result = tcgetattr (desc, &settings);
       if (result < 0)
         {
           perror ("error in tcgetattr");
           return 0;
         }
       settings.c_iflag &= ~ISTRIP;
       if (value)
         settings.c_iflag |= ISTRIP;
       result = tcsetattr (desc, TCSANOW, &settings);
       if (result < 0)
         {
           perror ("error in tcsetattr");
           return 0;
        }
       return 1;
     }


File: libc.info,  Node: Input Modes,  Next: Output Modes,  Prev: Setting Modes,  Up: Terminal Modes

17.4.4 Input Modes
------------------

This section describes the terminal attribute flags that control fairly
low-level aspects of input processing: handling of parity errors, break
signals, flow control, and <RET> and <LFD> characters.

   All of these flags are bits in the `c_iflag' member of the `struct
termios' structure.  The member is an integer, and you change flags
using the operators `&', `|' and `^'.  Don't try to specify the entire
value for `c_iflag'--instead, change only specific flags and leave the
rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t INPCK
     If this bit is set, input parity checking is enabled.  If it is
     not set, no checking at all is done for parity errors on input; the
     characters are simply passed through to the application.

     Parity checking on input processing is independent of whether
     parity detection and generation on the underlying terminal
     hardware is enabled; see *note Control Modes::.  For example, you
     could clear the `INPCK' input mode flag and set the `PARENB'
     control mode flag to ignore parity errors on input, but still
     generate parity on output.

     If this bit is set, what happens when a parity error is detected
     depends on whether the `IGNPAR' or `PARMRK' bits are set.  If
     neither of these bits are set, a byte with a parity error is
     passed to the application as a `'\0'' character.

 -- Macro: tcflag_t IGNPAR
     If this bit is set, any byte with a framing or parity error is
     ignored.  This is only useful if `INPCK' is also set.

 -- Macro: tcflag_t PARMRK
     If this bit is set, input bytes with parity or framing errors are
     marked when passed to the program.  This bit is meaningful only
     when `INPCK' is set and `IGNPAR' is not set.

     The way erroneous bytes are marked is with two preceding bytes,
     `377' and `0'.  Thus, the program actually reads three bytes for
     one erroneous byte received from the terminal.

     If a valid byte has the value `0377', and `ISTRIP' (see below) is
     not set, the program might confuse it with the prefix that marks a
     parity error.  So a valid byte `0377' is passed to the program as
     two bytes, `0377' `0377', in this case.

 -- Macro: tcflag_t ISTRIP
     If this bit is set, valid input bytes are stripped to seven bits;
     otherwise, all eight bits are available for programs to read.

 -- Macro: tcflag_t IGNBRK
     If this bit is set, break conditions are ignored.

     A "break condition" is defined in the context of asynchronous
     serial data transmission as a series of zero-value bits longer
     than a single byte.

 -- Macro: tcflag_t BRKINT
     If this bit is set and `IGNBRK' is not set, a break condition
     clears the terminal input and output queues and raises a `SIGINT'
     signal for the foreground process group associated with the
     terminal.

     If neither `BRKINT' nor `IGNBRK' are set, a break condition is
     passed to the application as a single `'\0'' character if `PARMRK'
     is not set, or otherwise as a three-character sequence `'\377'',
     `'\0'', `'\0''.

 -- Macro: tcflag_t IGNCR
     If this bit is set, carriage return characters (`'\r'') are
     discarded on input.  Discarding carriage return may be useful on
     terminals that send both carriage return and linefeed when you
     type the <RET> key.

 -- Macro: tcflag_t ICRNL
     If this bit is set and `IGNCR' is not set, carriage return
     characters (`'\r'') received as input are passed to the
     application as newline characters (`'\n'').

 -- Macro: tcflag_t INLCR
     If this bit is set, newline characters (`'\n'') received as input
     are passed to the application as carriage return characters
     (`'\r'').

 -- Macro: tcflag_t IXOFF
     If this bit is set, start/stop control on input is enabled.  In
     other words, the computer sends STOP and START characters as
     necessary to prevent input from coming in faster than programs are
     reading it.  The idea is that the actual terminal hardware that is
     generating the input data responds to a STOP character by
     suspending transmission, and to a START character by resuming
     transmission.  *Note Start/Stop Characters::.

 -- Macro: tcflag_t IXON
     If this bit is set, start/stop control on output is enabled.  In
     other words, if the computer receives a STOP character, it
     suspends output until a START character is received.  In this
     case, the STOP and START characters are never passed to the
     application program.  If this bit is not set, then START and STOP
     can be read as ordinary characters.  *Note Start/Stop Characters::.

 -- Macro: tcflag_t IXANY
     If this bit is set, any input character restarts output when
     output has been suspended with the STOP character.  Otherwise,
     only the START character restarts output.

     This is a BSD extension; it exists only on BSD systems and the GNU
     system.

 -- Macro: tcflag_t IMAXBEL
     If this bit is set, then filling up the terminal input buffer
     sends a BEL character (code `007') to the terminal to ring the
     bell.

     This is a BSD extension.


File: libc.info,  Node: Output Modes,  Next: Control Modes,  Prev: Input Modes,  Up: Terminal Modes

17.4.5 Output Modes
-------------------

This section describes the terminal flags and fields that control how
output characters are translated and padded for display.  All of these
are contained in the `c_oflag' member of the `struct termios' structure.

   The `c_oflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_oflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t OPOST
     If this bit is set, output data is processed in some unspecified
     way so that it is displayed appropriately on the terminal device.
     This typically includes mapping newline characters (`'\n'') onto
     carriage return and linefeed pairs.

     If this bit isn't set, the characters are transmitted as-is.

   The following three bits are BSD features, and they exist only BSD
systems and the GNU system.  They are effective only if `OPOST' is set.

 -- Macro: tcflag_t ONLCR
     If this bit is set, convert the newline character on output into a
     pair of characters, carriage return followed by linefeed.

 -- Macro: tcflag_t OXTABS
     If this bit is set, convert tab characters on output into the
     appropriate number of spaces to emulate a tab stop every eight
     columns.

 -- Macro: tcflag_t ONOEOT
     If this bit is set, discard `C-d' characters (code `004') on
     output.  These characters cause many dial-up terminals to
     disconnect.


File: libc.info,  Node: Control Modes,  Next: Local Modes,  Prev: Output Modes,  Up: Terminal Modes

17.4.6 Control Modes
--------------------

This section describes the terminal flags and fields that control
parameters usually associated with asynchronous serial data
transmission.  These flags may not make sense for other kinds of
terminal ports (such as a network connection pseudo-terminal).  All of
these are contained in the `c_cflag' member of the `struct termios'
structure.

   The `c_cflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_cflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t CLOCAL
     If this bit is set, it indicates that the terminal is connected
     "locally" and that the modem status lines (such as carrier detect)
     should be ignored.  

     On many systems if this bit is not set and you call `open' without
     the `O_NONBLOCK' flag set, `open' blocks until a modem connection
     is established.

     If this bit is not set and a modem disconnect is detected, a
     `SIGHUP' signal is sent to the controlling process group for the
     terminal (if it has one).  Normally, this causes the process to
     exit; see *note Signal Handling::.  Reading from the terminal
     after a disconnect causes an end-of-file condition, and writing
     causes an `EIO' error to be returned.  The terminal device must be
     closed and reopened to clear the condition.  

 -- Macro: tcflag_t HUPCL
     If this bit is set, a modem disconnect is generated when all
     processes that have the terminal device open have either closed
     the file or exited.

 -- Macro: tcflag_t CREAD
     If this bit is set, input can be read from the terminal.
     Otherwise, input is discarded when it arrives.

 -- Macro: tcflag_t CSTOPB
     If this bit is set, two stop bits are used.  Otherwise, only one
     stop bit is used.

 -- Macro: tcflag_t PARENB
     If this bit is set, generation and detection of a parity bit are
     enabled.  *Note Input Modes::, for information on how input parity
     errors are handled.

     If this bit is not set, no parity bit is added to output
     characters, and input characters are not checked for correct
     parity.

 -- Macro: tcflag_t PARODD
     This bit is only useful if `PARENB' is set.  If `PARODD' is set,
     odd parity is used, otherwise even parity is used.

   The control mode flags also includes a field for the number of bits
per character.  You can use the `CSIZE' macro as a mask to extract the
value, like this: `settings.c_cflag & CSIZE'.

 -- Macro: tcflag_t CSIZE
     This is a mask for the number of bits per character.

 -- Macro: tcflag_t CS5
     This specifies five bits per byte.

 -- Macro: tcflag_t CS6
     This specifies six bits per byte.

 -- Macro: tcflag_t CS7
     This specifies seven bits per byte.

 -- Macro: tcflag_t CS8
     This specifies eight bits per byte.

   The following four bits are BSD extensions; this exist only on BSD
systems and the GNU system.

 -- Macro: tcflag_t CCTS_OFLOW
     If this bit is set, enable flow control of output based on the CTS
     wire (RS232 protocol).

 -- Macro: tcflag_t CRTS_IFLOW
     If this bit is set, enable flow control of input based on the RTS
     wire (RS232 protocol).

 -- Macro: tcflag_t MDMBUF
     If this bit is set, enable carrier-based flow control of output.

 -- Macro: tcflag_t CIGNORE
     If this bit is set, it says to ignore the control modes and line
     speed values entirely.  This is only meaningful in a call to
     `tcsetattr'.

     The `c_cflag' member and the line speed values returned by
     `cfgetispeed' and `cfgetospeed' will be unaffected by the call.
     `CIGNORE' is useful if you want to set all the software modes in
     the other members, but leave the hardware details in `c_cflag'
     unchanged.  (This is how the `TCSASOFT' flag to `tcsettattr'
     works.)

     This bit is never set in the structure filled in by `tcgetattr'.


File: libc.info,  Node: Local Modes,  Next: Line Speed,  Prev: Control Modes,  Up: Terminal Modes

17.4.7 Local Modes
------------------

This section describes the flags for the `c_lflag' member of the
`struct termios' structure.  These flags generally control higher-level
aspects of input processing than the input modes flags described in
*note Input Modes::, such as echoing, signals, and the choice of
canonical or noncanonical input.

   The `c_lflag' member itself is an integer, and you change the flags
and fields using the operators `&', `|', and `^'.  Don't try to specify
the entire value for `c_lflag'--instead, change only specific flags and
leave the rest untouched (*note Setting Modes::).

 -- Macro: tcflag_t ICANON
     This bit, if set, enables canonical input processing mode.
     Otherwise, input is processed in noncanonical mode.  *Note
     Canonical or Not::.

 -- Macro: tcflag_t ECHO
     If this bit is set, echoing of input characters back to the
     terminal is enabled.  

 -- Macro: tcflag_t ECHOE
     If this bit is set, echoing indicates erasure of input with the
     ERASE character by erasing the last character in the current line
     from the screen.  Otherwise, the character erased is re-echoed to
     show what has happened (suitable for a printing terminal).

     This bit only controls the display behavior; the `ICANON' bit by
     itself controls actual recognition of the ERASE character and
     erasure of input, without which `ECHOE' is simply irrelevant.

 -- Macro: tcflag_t ECHOPRT
     This bit is like `ECHOE', enables display of the ERASE character in
     a way that is geared to a hardcopy terminal.  When you type the
     ERASE character, a `\' character is printed followed by the first
     character erased.  Typing the ERASE character again just prints
     the next character erased.  Then, the next time you type a normal
     character, a `/' character is printed before the character echoes.

     This is a BSD extension, and exists only in BSD systems and the
     GNU system.

 -- Macro: tcflag_t ECHOK
     This bit enables special display of the KILL character by moving
     to a new line after echoing the KILL character normally.  The
     behavior of `ECHOKE' (below) is nicer to look at.

     If this bit is not set, the KILL character echoes just as it would
     if it were not the KILL character.  Then it is up to the user to
     remember that the KILL character has erased the preceding input;
     there is no indication of this on the screen.

     This bit only controls the display behavior; the `ICANON' bit by
     itself controls actual recognition of the KILL character and
     erasure of input, without which `ECHOK' is simply irrelevant.

 -- Macro: tcflag_t ECHOKE
     This bit is similar to `ECHOK'.  It enables special display of the
     KILL character by erasing on the screen the entire line that has
     been killed.  This is a BSD extension, and exists only in BSD
     systems and the GNU system.

 -- Macro: tcflag_t ECHONL
     If this bit is set and the `ICANON' bit is also set, then the
     newline (`'\n'') character is echoed even if the `ECHO' bit is not
     set.

 -- Macro: tcflag_t ECHOCTL
     If this bit is set and the `ECHO' bit is also set, echo control
     characters with `^' followed by the corresponding text character.
     Thus, control-A echoes as `^A'.  This is usually the preferred mode
     for interactive input, because echoing a control character back to
     the terminal could have some undesired effect on the terminal.

     This is a BSD extension, and exists only in BSD systems and the
     GNU system.

 -- Macro: tcflag_t ISIG
     This bit controls whether the INTR, QUIT, and SUSP characters are
     recognized.  The functions associated with these characters are
     performed if and only if this bit is set.  Being in canonical or
     noncanonical input mode has no affect on the interpretation of
     these characters.

     You should use caution when disabling recognition of these
     characters.  Programs that cannot be interrupted interactively are
     very user-unfriendly.  If you clear this bit, your program should
     provide some alternate interface that allows the user to
     interactively send the signals associated with these characters,
     or to escape from the program.  

     *Note Signal Characters::.

 -- Macro: tcflag_t IEXTEN
     POSIX.1 gives `IEXTEN' implementation-defined meaning, so you
     cannot rely on this interpretation on all systems.

     On BSD systems and the GNU system, it enables the LNEXT and
     DISCARD characters.  *Note Other Special::.

 -- Macro: tcflag_t NOFLSH
     Normally, the INTR, QUIT, and SUSP characters cause input and
     output queues for the terminal to be cleared.  If this bit is set,
     the queues are not cleared.

 -- Macro: tcflag_t TOSTOP
     If this bit is set and the system supports job control, then
     `SIGTTOU' signals are generated by background processes that
     attempt to write to the terminal.  *Note Access to the Terminal::.

   The following bits are BSD extensions; they exist only in BSD systems
and the GNU system.

 -- Macro: tcflag_t ALTWERASE
     This bit determines how far the WERASE character should erase.  The
     WERASE character erases back to the beginning of a word; the
     question is, where do words begin?

     If this bit is clear, then the beginning of a word is a
     nonwhitespace character following a whitespace character.  If the
     bit is set, then the beginning of a word is an alphanumeric
     character or underscore following a character which is none of
     those.

     *Note Editing Characters::, for more information about the WERASE
     character.

 -- Macro: tcflag_t FLUSHO
     This is the bit that toggles when the user types the DISCARD
     character.  While this bit is set, all output is discarded.  *Note
     Other Special::.

 -- Macro: tcflag_t NOKERNINFO
     Setting this bit disables handling of the STATUS character.  *Note
     Other Special::.

 -- Macro: tcflag_t PENDIN
     If this bit is set, it indicates that there is a line of input that
     needs to be reprinted.  Typing the REPRINT character sets this
     bit; the bit remains set until reprinting is finished.  *Note
     Editing Characters::.


File: libc.info,  Node: Line Speed,  Next: Special Characters,  Prev: Local Modes,  Up: Terminal Modes

17.4.8 Line Speed
-----------------

The terminal line speed tells the computer how fast to read and write
data on the terminal.

   If the terminal is connected to a real serial line, the terminal
speed you specify actually controls the line--if it doesn't match the
terminal's own idea of the speed, communication does not work.  Real
serial ports accept only certain standard speeds.  Also, particular
hardware may not support even all the standard speeds.  Specifying a
speed of zero hangs up a dialup connection and turns off modem control
signals.

   If the terminal is not a real serial line (for example, if it is a
network connection), then the line speed won't really affect data
transmission speed, but some programs will use it to determine the
amount of padding needed.  It's best to specify a line speed value that
matches the actual speed of the actual terminal, but you can safely
experiment with different values to vary the amount of padding.

   There are actually two line speeds for each terminal, one for input
and one for output.  You can set them independently, but most often
terminals use the same speed for both directions.

   The speed values are stored in the `struct termios' structure, but
don't try to access them in the `struct termios' structure directly.
Instead, you should use the following functions to read and store them:

 -- Function: speed_t cfgetospeed (const struct termios *TERMIOS-P)
     This function returns the output line speed stored in the structure
     `*TERMIOS-P'.

 -- Function: speed_t cfgetispeed (const struct termios *TERMIOS-P)
     This function returns the input line speed stored in the structure
     `*TERMIOS-P'.

 -- Function: int cfsetospeed (struct termios *TERMIOS-P, speed_t SPEED)
     This function stores SPEED in `*TERMIOS-P' as the output speed.
     The normal return value is 0; a value of -1 indicates an error.
     If SPEED is not a speed, `cfsetospeed' returns -1.

 -- Function: int cfsetispeed (struct termios *TERMIOS-P, speed_t SPEED)
     This function stores SPEED in `*TERMIOS-P' as the input speed.
     The normal return value is 0; a value of -1 indicates an error.
     If SPEED is not a speed, `cfsetospeed' returns -1.

 -- Function: int cfsetspeed (struct termios *TERMIOS-P, speed_t SPEED)
     This function stores SPEED in `*TERMIOS-P' as both the input and
     output speeds.  The normal return value is 0; a value of -1
     indicates an error.  If SPEED is not a speed, `cfsetspeed' returns
     -1.  This function is an extension in 4.4 BSD.

 -- Data Type: speed_t
     The `speed_t' type is an unsigned integer data type used to
     represent line speeds.

   The functions `cfsetospeed' and `cfsetispeed' report errors only for
speed values that the system simply cannot handle.  If you specify a
speed value that is basically acceptable, then those functions will
succeed.  But they do not check that a particular hardware device can
actually support the specified speeds--in fact, they don't know which
device you plan to set the speed for.  If you use `tcsetattr' to set
the speed of a particular device to a value that it cannot handle,
`tcsetattr' returns -1.

   *Portability note:* In the GNU library, the functions above accept
speeds measured in bits per second as input, and return speed values
measured in bits per second.  Other libraries require speeds to be
indicated by special codes.  For POSIX.1 portability, you must use one
of the following symbols to represent the speed; their precise numeric
values are system-dependent, but each name has a fixed meaning: `B110'
stands for 110 bps, `B300' for 300 bps, and so on.  There is no
portable way to represent any speed but these, but these are the only
speeds that typical serial lines can support.

     B0  B50  B75  B110  B134  B150  B200
     B300  B600  B1200  B1800  B2400  B4800
     B9600  B19200  B38400  B57600  B115200
     B230400  B460800

   BSD defines two additional speed symbols as aliases: `EXTA' is an
alias for `B19200' and `EXTB' is an alias for `B38400'.  These aliases
are obsolete.


File: libc.info,  Node: Special Characters,  Next: Noncanonical Input,  Prev: Line Speed,  Up: Terminal Modes

17.4.9 Special Characters
-------------------------

In canonical input, the terminal driver recognizes a number of special
characters which perform various control functions.  These include the
ERASE character (usually <DEL>) for editing input, and other editing
characters.  The INTR character (normally `C-c') for sending a `SIGINT'
signal, and other signal-raising characters, may be available in either
canonical or noncanonical input mode.  All these characters are
described in this section.

   The particular characters used are specified in the `c_cc' member of
the `struct termios' structure.  This member is an array; each element
specifies the character for a particular role.  Each element has a
symbolic constant that stands for the index of that element--for
example, `VINTR' is the index of the element that specifies the INTR
character, so storing `'='' in `TERMIOS.c_cc[VINTR]' specifies `=' as
the INTR character.

   On some systems, you can disable a particular special character
function by specifying the value `_POSIX_VDISABLE' for that role.  This
value is unequal to any possible character code.  *Note Options for
Files::, for more information about how to tell whether the operating
system you are using supports `_POSIX_VDISABLE'.

* Menu:

* Editing Characters::          Special characters that terminate lines and
                                  delete text, and other editing functions.
* Signal Characters::           Special characters that send or raise signals
                                  to or for certain classes of processes.
* Start/Stop Characters::       Special characters that suspend or resume
                                  suspended output.
* Other Special::		Other special characters for BSD systems:
				  they can discard output, and print status.


File: libc.info,  Node: Editing Characters,  Next: Signal Characters,  Up: Special Characters

17.4.9.1 Characters for Input Editing
.....................................

These special characters are active only in canonical input mode.
*Note Canonical or Not::.

 -- Macro: int VEOF
     This is the subscript for the EOF character in the special control
     character array.  `TERMIOS.c_cc[VEOF]' holds the character itself.

     The EOF character is recognized only in canonical input mode.  It
     acts as a line terminator in the same way as a newline character,
     but if the EOF character is typed at the beginning of a line it
     causes `read' to return a byte count of zero, indicating
     end-of-file.  The EOF character itself is discarded.

     Usually, the EOF character is `C-d'.

 -- Macro: int VEOL
     This is the subscript for the EOL character in the special control
     character array.  `TERMIOS.c_cc[VEOL]' holds the character itself.

     The EOL character is recognized only in canonical input mode.  It
     acts as a line terminator, just like a newline character.  The EOL
     character is not discarded; it is read as the last character in
     the input line.

     You don't need to use the EOL character to make <RET> end a line.
     Just set the ICRNL flag.  In fact, this is the default state of
     affairs.

 -- Macro: int VEOL2
     This is the subscript for the EOL2 character in the special control
     character array.  `TERMIOS.c_cc[VEOL2]' holds the character itself.

     The EOL2 character works just like the EOL character (see above),
     but it can be a different character.  Thus, you can specify two
     characters to terminate an input line, by setting EOL to one of
     them and EOL2 to the other.

     The EOL2 character is a BSD extension; it exists only on BSD
     systems and the GNU system.

 -- Macro: int VERASE
     This is the subscript for the ERASE character in the special
     control character array.  `TERMIOS.c_cc[VERASE]' holds the
     character itself.

     The ERASE character is recognized only in canonical input mode.
     When the user types the erase character, the previous character
     typed is discarded.  (If the terminal generates multibyte
     character sequences, this may cause more than one byte of input to
     be discarded.)  This cannot be used to erase past the beginning of
     the current line of text.  The ERASE character itself is discarded.

     Usually, the ERASE character is <DEL>.

 -- Macro: int VWERASE
     This is the subscript for the WERASE character in the special
     control character array.  `TERMIOS.c_cc[VWERASE]' holds the
     character itself.

     The WERASE character is recognized only in canonical mode.  It
     erases an entire word of prior input, and any whitespace after it;
     whitespace characters before the word are not erased.

     The definition of a "word" depends on the setting of the
     `ALTWERASE' mode; *note Local Modes::.

     If the `ALTWERASE' mode is not set, a word is defined as a sequence
     of any characters except space or tab.

     If the `ALTWERASE' mode is set, a word is defined as a sequence of
     characters containing only letters, numbers, and underscores,
     optionally followed by one character that is not a letter, number,
     or underscore.

     The WERASE character is usually `C-w'.

     This is a BSD extension.

 -- Macro: int VKILL
     This is the subscript for the KILL character in the special control
     character array.  `TERMIOS.c_cc[VKILL]' holds the character itself.

     The KILL character is recognized only in canonical input mode.
     When the user types the kill character, the entire contents of the
     current line of input are discarded.  The kill character itself is
     discarded too.

     The KILL character is usually `C-u'.

 -- Macro: int VREPRINT
     This is the subscript for the REPRINT character in the special
     control character array.  `TERMIOS.c_cc[VREPRINT]' holds the
     character itself.

     The REPRINT character is recognized only in canonical mode.  It
     reprints the current input line.  If some asynchronous output has
     come while you are typing, this lets you see the line you are
     typing clearly again.

     The REPRINT character is usually `C-r'.

     This is a BSD extension.


File: libc.info,  Node: Signal Characters,  Next: Start/Stop Characters,  Prev: Editing Characters,  Up: Special Characters

17.4.9.2 Characters that Cause Signals
......................................

These special characters may be active in either canonical or
noncanonical input mode, but only when the `ISIG' flag is set (*note
Local Modes::).

 -- Macro: int VINTR
     This is the subscript for the INTR character in the special control
     character array.  `TERMIOS.c_cc[VINTR]' holds the character itself.

     The INTR (interrupt) character raises a `SIGINT' signal for all
     processes in the foreground job associated with the terminal.  The
     INTR character itself is then discarded.  *Note Signal Handling::,
     for more information about signals.

     Typically, the INTR character is `C-c'.

 -- Macro: int VQUIT
     This is the subscript for the QUIT character in the special control
     character array.  `TERMIOS.c_cc[VQUIT]' holds the character itself.

     The QUIT character raises a `SIGQUIT' signal for all processes in
     the foreground job associated with the terminal.  The QUIT
     character itself is then discarded.  *Note Signal Handling::, for
     more information about signals.

     Typically, the QUIT character is `C-\'.

 -- Macro: int VSUSP
     This is the subscript for the SUSP character in the special control
     character array.  `TERMIOS.c_cc[VSUSP]' holds the character itself.

     The SUSP (suspend) character is recognized only if the
     implementation supports job control (*note Job Control::).  It
     causes a `SIGTSTP' signal to be sent to all processes in the
     foreground job associated with the terminal.  The SUSP character
     itself is then discarded.  *Note Signal Handling::, for more
     information about signals.

     Typically, the SUSP character is `C-z'.

   Few applications disable the normal interpretation of the SUSP
character.  If your program does this, it should provide some other
mechanism for the user to stop the job.  When the user invokes this
mechanism, the program should send a `SIGTSTP' signal to the process
group of the process, not just to the process itself.  *Note Signaling
Another Process::.

 -- Macro: int VDSUSP
     This is the subscript for the DSUSP character in the special
     control character array.  `TERMIOS.c_cc[VDSUSP]' holds the
     character itself.

     The DSUSP (suspend) character is recognized only if the
     implementation supports job control (*note Job Control::).  It
     sends a `SIGTSTP' signal, like the SUSP character, but not right
     away--only when the program tries to read it as input.  Not all
     systems with job control support DSUSP; only BSD-compatible
     systems (including the GNU system).

     *Note Signal Handling::, for more information about signals.

     Typically, the DSUSP character is `C-y'.


File: libc.info,  Node: Start/Stop Characters,  Next: Other Special,  Prev: Signal Characters,  Up: Special Characters

17.4.9.3 Special Characters for Flow Control
............................................

These special characters may be active in either canonical or
noncanonical input mode, but their use is controlled by the flags
`IXON' and `IXOFF' (*note Input Modes::).

 -- Macro: int VSTART
     This is the subscript for the START character in the special
     control character array.  `TERMIOS.c_cc[VSTART]' holds the
     character itself.

     The START character is used to support the `IXON' and `IXOFF'
     input modes.  If `IXON' is set, receiving a START character resumes
     suspended output; the START character itself is discarded.  If
     `IXANY' is set, receiving any character at all resumes suspended
     output; the resuming character is not discarded unless it is the
     START character.  `IXOFF' is set, the system may also transmit
     START characters to the terminal.

     The usual value for the START character is `C-q'.  You may not be
     able to change this value--the hardware may insist on using `C-q'
     regardless of what you specify.

 -- Macro: int VSTOP
     This is the subscript for the STOP character in the special control
     character array.  `TERMIOS.c_cc[VSTOP]' holds the character itself.

     The STOP character is used to support the `IXON' and `IXOFF' input
     modes.  If `IXON' is set, receiving a STOP character causes output
     to be suspended; the STOP character itself is discarded.  If
     `IXOFF' is set, the system may also transmit STOP characters to the
     terminal, to prevent the input queue from overflowing.

     The usual value for the STOP character is `C-s'.  You may not be
     able to change this value--the hardware may insist on using `C-s'
     regardless of what you specify.


File: libc.info,  Node: Other Special,  Prev: Start/Stop Characters,  Up: Special Characters

17.4.9.4 Other Special Characters
.................................

These special characters exist only in BSD systems and the GNU system.

 -- Macro: int VLNEXT
     This is the subscript for the LNEXT character in the special
     control character array.  `TERMIOS.c_cc[VLNEXT]' holds the
     character itself.

     The LNEXT character is recognized only when `IEXTEN' is set, but in
     both canonical and noncanonical mode.  It disables any special
     significance of the next character the user types.  Even if the
     character would normally perform some editing function or generate
     a signal, it is read as a plain character.  This is the analogue
     of the `C-q' command in Emacs.  "LNEXT" stands for "literal next."

     The LNEXT character is usually `C-v'.

 -- Macro: int VDISCARD
     This is the subscript for the DISCARD character in the special
     control character array.  `TERMIOS.c_cc[VDISCARD]' holds the
     character itself.

     The DISCARD character is recognized only when `IEXTEN' is set, but
     in both canonical and noncanonical mode.  Its effect is to toggle
     the discard-output flag.  When this flag is set, all program
     output is discarded.  Setting the flag also discards all output
     currently in the output buffer.  Typing any other character resets
     the flag.

 -- Macro: int VSTATUS
     This is the subscript for the STATUS character in the special
     control character array.  `TERMIOS.c_cc[VSTATUS]' holds the
     character itself.

     The STATUS character's effect is to print out a status message
     about how the current process is running.

     The STATUS character is recognized only in canonical mode, and
     only if `NOKERNINFO' is not set.


File: libc.info,  Node: Noncanonical Input,  Prev: Special Characters,  Up: Terminal Modes

17.4.10 Noncanonical Input
--------------------------

In noncanonical input mode, the special editing characters such as
ERASE and KILL are ignored.  The system facilities for the user to edit
input are disabled in noncanonical mode, so that all input characters
(unless they are special for signal or flow-control purposes) are passed
to the application program exactly as typed.  It is up to the
application program to give the user ways to edit the input, if
appropriate.

   Noncanonical mode offers special parameters called MIN and TIME for
controlling whether and how long to wait for input to be available.  You
can even use them to avoid ever waiting--to return immediately with
whatever input is available, or with no input.

   The MIN and TIME are stored in elements of the `c_cc' array, which
is a member of the `struct termios' structure.  Each element of this
array has a particular role, and each element has a symbolic constant
that stands for the index of that element.  `VMIN' and `VMAX' are the
names for the indices in the array of the MIN and TIME slots.

 -- Macro: int VMIN
     This is the subscript for the MIN slot in the `c_cc' array.  Thus,
     `TERMIOS.c_cc[VMIN]' is the value itself.

     The MIN slot is only meaningful in noncanonical input mode; it
     specifies the minimum number of bytes that must be available in the
     input queue in order for `read' to return.

 -- Macro: int VTIME
     This is the subscript for the TIME slot in the `c_cc' array.  Thus,
     `TERMIOS.c_cc[VTIME]' is the value itself.

     The TIME slot is only meaningful in noncanonical input mode; it
     specifies how long to wait for input before returning, in units of
     0.1 seconds.

   The MIN and TIME values interact to determine the criterion for when
`read' should return; their precise meanings depend on which of them
are nonzero.  There are four possible cases:

   * Both TIME and MIN are nonzero.

     In this case, TIME specifies how long to wait after each input
     character to see if more input arrives.  After the first character
     received, `read' keeps waiting until either MIN bytes have arrived
     in all, or TIME elapses with no further input.

     `read' always blocks until the first character arrives, even if
     TIME elapses first.  `read' can return more than MIN characters if
     more than MIN happen to be in the queue.

   * Both MIN and TIME are zero.

     In this case, `read' always returns immediately with as many
     characters as are available in the queue, up to the number
     requested.  If no input is immediately available, `read' returns a
     value of zero.

   * MIN is zero but TIME has a nonzero value.

     In this case, `read' waits for time TIME for input to become
     available; the availability of a single byte is enough to satisfy
     the read request and cause `read' to return.  When it returns, it
     returns as many characters as are available, up to the number
     requested.  If no input is available before the timer expires,
     `read' returns a value of zero.

   * TIME is zero but MIN has a nonzero value.

     In this case, `read' waits until at least MIN bytes are available
     in the queue.  At that time, `read' returns as many characters as
     are available, up to the number requested.  `read' can return more
     than MIN characters if more than MIN happen to be in the queue.

   What happens if MIN is 50 and you ask to read just 10 bytes?
Normally, `read' waits until there are 50 bytes in the buffer (or, more
generally, the wait condition described above is satisfied), and then
reads 10 of them, leaving the other 40 buffered in the operating system
for a subsequent call to `read'.

   *Portability note:* On some systems, the MIN and TIME slots are
actually the same as the EOF and EOL slots.  This causes no serious
problem because the MIN and TIME slots are used only in noncanonical
input and the EOF and EOL slots are used only in canonical input, but it
isn't very clean.  The GNU library allocates separate slots for these
uses.

 -- Function: void cfmakeraw (struct termios *TERMIOS-P)
     This function provides an easy way to set up `*TERMIOS-P' for what
     has traditionally been called "raw mode" in BSD.  This uses
     noncanonical input, and turns off most processing to give an
     unmodified channel to the terminal.

     It does exactly this:
            TERMIOS-P->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                                          |INLCR|IGNCR|ICRNL|IXON);
            TERMIOS-P->c_oflag &= ~OPOST;
            TERMIOS-P->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
            TERMIOS-P->c_cflag &= ~(CSIZE|PARENB);
            TERMIOS-P->c_cflag |= CS8;


File: libc.info,  Node: BSD Terminal Modes,  Next: Line Control,  Prev: Terminal Modes,  Up: Low-Level Terminal Interface

17.5 BSD Terminal Modes
=======================

The usual way to get and set terminal modes is with the functions
described in *note Terminal Modes::.  However, on some systems you can
use the BSD-derived functions in this section to do some of the same
thing.  On many systems, these functions do not exist.  Even with the
GNU C library, the functions simply fail with `errno' = `ENOSYS' with
many kernels, including Linux.

   The symbols used in this section are declared in `sgtty.h'.

 -- Data Type: struct sgttyb
     This structure is an input or output parameter list for `gtty' and
     `stty'.

    `char sg_ispeed'
          Line speed for input

    `char sg_ospeed'
          Line speed for output

    `char sg_erase'
          Erase character

    `char sg_kill'
          Kill character

    `int sg_flags'
          Various flags

 -- Function: int gtty (int FILEDES, struct sgttyb *ATTRIBUTES)
     This function gets the attributes of a terminal.

     `gtty' sets *ATTRIBUTES to describe the terminal attributes of the
     terminal which is open with file descriptor FILEDES.

 -- Function: int stty (int FILEDES, struct sgttyb * attributes)
     This function sets the attributes of a terminal.

     `stty' sets the terminal attributes of the terminal which is open
     with file descriptor FILEDES to those described by *FILEDES.


File: libc.info,  Node: Line Control,  Next: Noncanon Example,  Prev: BSD Terminal Modes,  Up: Low-Level Terminal Interface

17.6 Line Control Functions
===========================

These functions perform miscellaneous control actions on terminal
devices.  As regards terminal access, they are treated like doing
output: if any of these functions is used by a background process on its
controlling terminal, normally all processes in the process group are
sent a `SIGTTOU' signal.  The exception is if the calling process
itself is ignoring or blocking `SIGTTOU' signals, in which case the
operation is performed and no signal is sent.  *Note Job Control::.

 -- Function: int tcsendbreak (int FILEDES, int DURATION)
     This function generates a break condition by transmitting a stream
     of zero bits on the terminal associated with the file descriptor
     FILEDES.  The duration of the break is controlled by the DURATION
     argument.  If zero, the duration is between 0.25 and 0.5 seconds.
     The meaning of a nonzero value depends on the operating system.

     This function does nothing if the terminal is not an asynchronous
     serial data port.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

 -- Function: int tcdrain (int FILEDES)
     The `tcdrain' function waits until all queued output to the
     terminal FILEDES has been transmitted.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     `tcdrain' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     `tcdrain' should be protected using cancellation handlers.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

    `EINTR'
          The operation was interrupted by delivery of a signal.  *Note
          Interrupted Primitives::.

 -- Function: int tcflush (int FILEDES, int QUEUE)
     The `tcflush' function is used to clear the input and/or output
     queues associated with the terminal file FILEDES.  The QUEUE
     argument specifies which queue(s) to clear, and can be one of the
     following values:

    `TCIFLUSH'
          Clear any input data received, but not yet read.

    `TCOFLUSH'
          Clear any output data written, but not yet transmitted.

    `TCIOFLUSH'
          Clear both queued input and output.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

    `EINVAL'
          A bad value was supplied as the QUEUE argument.

     It is unfortunate that this function is named `tcflush', because
     the term "flush" is normally used for quite another
     operation--waiting until all output is transmitted--and using it
     for discarding input or output would be confusing.  Unfortunately,
     the name `tcflush' comes from POSIX and we cannot change it.

 -- Function: int tcflow (int FILEDES, int ACTION)
     The `tcflow' function is used to perform operations relating to
     XON/XOFF flow control on the terminal file specified by FILEDES.

     The ACTION argument specifies what operation to perform, and can
     be one of the following values:

    `TCOOFF'
          Suspend transmission of output.

    `TCOON'
          Restart transmission of output.

    `TCIOFF'
          Transmit a STOP character.

    `TCION'
          Transmit a START character.

     For more information about the STOP and START characters, see
     *note Special Characters::.

     The return value is normally zero.  In the event of an error, a
     value of -1 is returned.  The following `errno' error conditions
     are defined for this function:

    `EBADF'
          The FILEDES is not a valid file descriptor.

    `ENOTTY'
          The FILEDES is not associated with a terminal device.

    `EINVAL'
          A bad value was supplied as the ACTION argument.


File: libc.info,  Node: Noncanon Example,  Next: Pseudo-Terminals,  Prev: Line Control,  Up: Low-Level Terminal Interface

17.7 Noncanonical Mode Example
==============================

Here is an example program that shows how you can set up a terminal
device to read single characters in noncanonical input mode, without
echo.

     #include <unistd.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <termios.h>

     /* Use this variable to remember original terminal attributes. */

     struct termios saved_attributes;

     void
     reset_input_mode (void)
     {
       tcsetattr (STDIN_FILENO, TCSANOW, &saved_attributes);
     }

     void
     set_input_mode (void)
     {
       struct termios tattr;
       char *name;

       /* Make sure stdin is a terminal. */
       if (!isatty (STDIN_FILENO))
         {
           fprintf (stderr, "Not a terminal.\n");
           exit (EXIT_FAILURE);
         }

       /* Save the terminal attributes so we can restore them later. */
       tcgetattr (STDIN_FILENO, &saved_attributes);
       atexit (reset_input_mode);

       /* Set the funny terminal modes. */
       tcgetattr (STDIN_FILENO, &tattr);
       tattr.c_lflag &= ~(ICANON|ECHO); /* Clear ICANON and ECHO. */
       tattr.c_cc[VMIN] = 1;
       tattr.c_cc[VTIME] = 0;
       tcsetattr (STDIN_FILENO, TCSAFLUSH, &tattr);
     }

     int
     main (void)
     {
       char c;

       set_input_mode ();

       while (1)
         {
           read (STDIN_FILENO, &c, 1);
           if (c == '\004')          /* `C-d' */
             break;
           else
             putchar (c);
         }

       return EXIT_SUCCESS;
     }

   This program is careful to restore the original terminal modes before
exiting or terminating with a signal.  It uses the `atexit' function
(*note Cleanups on Exit::) to make sure this is done by `exit'.

   The shell is supposed to take care of resetting the terminal modes
when a process is stopped or continued; see *note Job Control::.  But
some existing shells do not actually do this, so you may wish to
establish handlers for job control signals that reset terminal modes.
The above example does so.


File: libc.info,  Node: Pseudo-Terminals,  Prev: Noncanon Example,  Up: Low-Level Terminal Interface

17.8 Pseudo-Terminals
=====================

A "pseudo-terminal" is a special interprocess communication channel
that acts like a terminal.  One end of the channel is called the
"master" side or "master pseudo-terminal device", the other side is
called the "slave" side.  Data written to the master side is received
by the slave side as if it was the result of a user typing at an
ordinary terminal, and data written to the slave side is sent to the
master side as if it was written on an ordinary terminal.

   Pseudo terminals are the way programs like `xterm' and `emacs'
implement their terminal emulation functionality.

* Menu:

* Allocation::             Allocating a pseudo terminal.
* Pseudo-Terminal Pairs::  How to open both sides of a
                            pseudo-terminal in a single operation.


File: libc.info,  Node: Allocation,  Next: Pseudo-Terminal Pairs,  Up: Pseudo-Terminals

17.8.1 Allocating Pseudo-Terminals
----------------------------------

This subsection describes functions for allocating a pseudo-terminal,
and for making this pseudo-terminal available for actual use.  These
functions are declared in the header file `stdlib.h'.

 -- Function: int getpt (void)
     The `getpt' function returns a new file descriptor for the next
     available master pseudo-terminal.  The normal return value from
     `getpt' is a non-negative integer file descriptor.  In the case of
     an error, a value of -1 is returned instead.  The following
     `errno' conditions are defined for this function:

    `ENOENT'
          There are no free master pseudo-terminals available.

     This function is a GNU extension.

 -- Function: int grantpt (int FILEDES)
     The `grantpt' function changes the ownership and access permission
     of the slave pseudo-terminal device corresponding to the master
     pseudo-terminal device associated with the file descriptor
     FILEDES.  The owner is set from the real user ID of the calling
     process (*note Process Persona::), and the group is set to a
     special group (typically "tty") or from the real group ID of the
     calling process.  The access permission is set such that the file
     is both readable and writable by the owner and only writable by
     the group.

     On some systems this function is implemented by invoking a special
     `setuid' root program (*note How Change Persona::).  As a
     consequence, installing a signal handler for the `SIGCHLD' signal
     (*note Job Control Signals::) may interfere with a call to
     `grantpt'.

     The normal return value from `grantpt' is 0; a value of -1 is
     returned in case of failure.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The FILEDES argument is not associated with a master
          pseudo-terminal device.

    `EACCES'
          The slave pseudo-terminal device corresponding to the master
          associated with FILEDES could not be accessed.


 -- Function: int unlockpt (int FILEDES)
     The `unlockpt' function unlocks the slave pseudo-terminal device
     corresponding to the master pseudo-terminal device associated with
     the file descriptor FILEDES.  On many systems, the slave can only
     be opened after unlocking, so portable applications should always
     call `unlockpt' before trying to open the slave.

     The normal return value from `unlockpt' is 0; a value of -1 is
     returned in case of failure.  The following `errno' error
     conditions are defined for this function:

    `EBADF'
          The FILEDES argument is not a valid file descriptor.

    `EINVAL'
          The FILEDES argument is not associated with a master
          pseudo-terminal device.

 -- Function: char * ptsname (int FILEDES)
     If the file descriptor FILEDES is associated with a master
     pseudo-terminal device, the `ptsname' function returns a pointer
     to a statically-allocated, null-terminated string containing the
     file name of the associated slave pseudo-terminal file.  This
     string might be overwritten by subsequent calls to `ptsname'.

 -- Function: int ptsname_r (int FILEDES, char *BUF, size_t LEN)
     The `ptsname_r' function is similar to the `ptsname' function
     except that it places its result into the user-specified buffer
     starting at BUF with length LEN.

     This function is a GNU extension.

   *Portability Note:* On System V derived systems, the file returned
by the `ptsname' and `ptsname_r' functions may be STREAMS-based, and
therefore require additional processing after opening before it
actually behaves as a pseudo terminal.

   Typical usage of these functions is illustrated by the following
example:
     int
     open_pty_pair (int *amaster, int *aslave)
     {
       int master, slave;
       char *name;

       master = getpt ();
       if (master < 0)
         return 0;

       if (grantpt (master) < 0 || unlockpt (master) < 0)
         goto close_master;
       name = ptsname (master);
       if (name == NULL)
         goto close_master;

       slave = open (name, O_RDWR);
       if (slave == -1)
         goto close_master;

       if (isastream (slave))
         {
           if (ioctl (slave, I_PUSH, "ptem") < 0
               || ioctl (slave, I_PUSH, "ldterm") < 0)
             goto close_slave;
         }

       *amaster = master;
       *aslave = slave;
       return 1;

     close_slave:
       close (slave);

     close_master:
       close (master);
       return 0;
     }


File: libc.info,  Node: Pseudo-Terminal Pairs,  Prev: Allocation,  Up: Pseudo-Terminals

17.8.2 Opening a Pseudo-Terminal Pair
-------------------------------------

These functions, derived from BSD, are available in the separate
`libutil' library, and declared in `pty.h'.

 -- Function: int openpty (int *AMASTER, int *ASLAVE, char *NAME, const
          struct termios *TERMP, const struct winsize *WINP)
     This function allocates and opens a pseudo-terminal pair,
     returning the file descriptor for the master in *AMASTER, and the
     file descriptor for the slave in *ASLAVE.  If the argument NAME is
     not a null pointer, the file name of the slave pseudo-terminal
     device is stored in `*name'.  If TERMP is not a null pointer, the
     terminal attributes of the slave are set to the ones specified in
     the structure that TERMP points to (*note Terminal Modes::).
     Likewise, if the WINP is not a null pointer, the screen size of
     the slave is set to the values specified in the structure that
     WINP points to.

     The normal return value from `openpty' is 0; a value of -1 is
     returned in case of failure.  The following `errno' conditions are
     defined for this function:

    `ENOENT'
          There are no free pseudo-terminal pairs available.

     *Warning:* Using the `openpty' function with NAME not set to
     `NULL' is *very dangerous* because it provides no protection
     against overflowing the string NAME.  You should use the `ttyname'
     function on the file descriptor returned in *SLAVE to find out the
     file name of the slave pseudo-terminal device instead.

 -- Function: int forkpty (int *AMASTER, char *NAME, const struct
          termios *TERMP, const struct winsize *WINP)
     This function is similar to the `openpty' function, but in
     addition, forks a new process (*note Creating a Process::) and
     makes the newly opened slave pseudo-terminal device the
     controlling terminal (*note Controlling Terminal::) for the child
     process.

     If the operation is successful, there are then both parent and
     child processes and both see `forkpty' return, but with different
     values: it returns a value of 0 in the child process and returns
     the child's process ID in the parent process.

     If the allocation of a pseudo-terminal pair or the process creation
     failed, `forkpty' returns a value of -1 in the parent process.

     *Warning:* The `forkpty' function has the same problems with
     respect to the NAME argument as `openpty'.


File: libc.info,  Node: Syslog,  Next: Mathematics,  Prev: Low-Level Terminal Interface,  Up: Top

18 Syslog
*********

This chapter describes facilities for issuing and logging messages of
system administration interest.  This chapter has nothing to do with
programs issuing messages to their own users or keeping private logs
(One would typically do that with the facilities described in *note I/O
on Streams::).

   Most systems have a facility called "Syslog" that allows programs to
submit messages of interest to system administrators and can be
configured to pass these messages on in various ways, such as printing
on the console, mailing to a particular person, or recording in a log
file for future reference.

   A program uses the facilities in this chapter to submit such
messages.

* Menu:

* Overview of Syslog::           Overview of a system's Syslog facility
* Submitting Syslog Messages::   Functions to submit messages to Syslog


File: libc.info,  Node: Overview of Syslog,  Next: Submitting Syslog Messages,  Up: Syslog

18.1 Overview of Syslog
=======================

System administrators have to deal with lots of different kinds of
messages from a plethora of subsystems within each system, and usually
lots of systems as well.  For example, an FTP server might report every
connection it gets.  The kernel might report hardware failures on a disk
drive.  A DNS server might report usage statistics at regular intervals.

   Some of these messages need to be brought to a system administrator's
attention immediately.  And it may not be just any system administrator
- there may be a particular system administrator who deals with a
particular kind of message.  Other messages just need to be recorded for
future reference if there is a problem.  Still others may need to have
information extracted from them by an automated process that generates
monthly reports.

   To deal with these messages, most Unix systems have a facility called
"Syslog."  It is generally based on a daemon called "Syslogd" Syslogd
listens for messages on a Unix domain socket named `/dev/log'.  Based
on classification information in the messages and its configuration
file (usually `/etc/syslog.conf'), Syslogd routes them in various ways.
Some of the popular routings are:

   * Write to the system console

   * Mail to a specific user

   * Write to a log file

   * Pass to another daemon

   * Discard

   Syslogd can also handle messages from other systems.  It listens on
the `syslog' UDP port as well as the local socket for messages.

   Syslog can handle messages from the kernel itself.  But the kernel
doesn't write to `/dev/log'; rather, another daemon (sometimes called
"Klogd") extracts messages from the kernel and passes them on to Syslog
as any other process would (and it properly identifies them as messages
from the kernel).

   Syslog can even handle messages that the kernel issued before
Syslogd or Klogd was running.  A Linux kernel, for example, stores
startup messages in a kernel message ring and they are normally still
there when Klogd later starts up.  Assuming Syslogd is running by the
time Klogd starts, Klogd then passes everything in the message ring to
it.

   In order to classify messages for disposition, Syslog requires any
process that submits a message to it to provide two pieces of
classification information with it:

facility
     This identifies who submitted the message.  There are a small
     number of facilities defined.  The kernel, the mail subsystem, and
     an FTP server are examples of recognized facilities.  For the
     complete list, *Note syslog; vsyslog::.  Keep in mind that these
     are essentially arbitrary classifications.  "Mail subsystem"
     doesn't have any more meaning than the system administrator gives
     to it.

priority
     This tells how important the content of the message is.  Examples
     of defined priority values are: debug, informational, warning,
     critical.  For the complete list, see *note syslog; vsyslog::.
     Except for the fact that the priorities have a defined order, the
     meaning of each of these priorities is entirely determined by the
     system administrator.


   A "facility/priority" is a number that indicates both the facility
and the priority.

   *Warning:* This terminology is not universal.  Some people use
"level" to refer to the priority and "priority" to refer to the
combination of facility and priority.  A Linux kernel has a concept of a
message "level," which corresponds both to a Syslog priority and to a
Syslog facility/priority (It can be both because the facility code for
the kernel is zero, and that makes priority and facility/priority the
same value).

   The GNU C library provides functions to submit messages to Syslog.
They do it by writing to the `/dev/log' socket.  *Note Submitting
Syslog Messages::.

   The GNU C library functions only work to submit messages to the
Syslog facility on the same system.  To submit a message to the Syslog
facility on another system, use the socket I/O functions to write a UDP
datagram to the `syslog' UDP port on that system.  *Note Sockets::.


File: libc.info,  Node: Submitting Syslog Messages,  Prev: Overview of Syslog,  Up: Syslog

18.2 Submitting Syslog Messages
===============================

The GNU C library provides functions to submit messages to the Syslog
facility:

* Menu:

* openlog::                      Open connection to Syslog
* syslog; vsyslog::              Submit message to Syslog
* closelog::                     Close connection to Syslog
* setlogmask::                   Cause certain messages to be ignored
* Syslog Example::               Example of all of the above

   These functions only work to submit messages to the Syslog facility
on the same system.  To submit a message to the Syslog facility on
another system, use the socket I/O functions to write a UDP datagram to
the `syslog' UDP port on that system.  *Note Sockets::.


File: libc.info,  Node: openlog,  Next: syslog; vsyslog,  Up: Submitting Syslog Messages

18.2.1 openlog
--------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: void openlog (const char *IDENT, int OPTION, int FACILITY)
     `openlog' opens or reopens a connection to Syslog in preparation
     for submitting messages.

     IDENT is an arbitrary identification string which future `syslog'
     invocations will prefix to each message.  This is intended to
     identify the source of the message, and people conventionally set
     it to the name of the program that will submit the messages.

     If IDENT is NULL, or if `openlog' is not called, the default
     identification string used in Syslog messages will be the program
     name, taken from argv[0].

     Please note that the string pointer IDENT will be retained
     internally by the Syslog routines.  You must not free the memory
     that IDENT points to.  It is also dangerous to pass a reference to
     an automatic variable since leaving the scope would mean ending the
     lifetime of the variable.  If you want to change the IDENT string,
     you must call `openlog' again; overwriting the string pointed to by
     IDENT is not thread-safe.

     You can cause the Syslog routines to drop the reference to IDENT
     and go back to the default string (the program name taken from
     argv[0]), by calling `closelog': *Note closelog::.

     In particular, if you are writing code for a shared library that
     might get loaded and then unloaded (e.g. a PAM module), and you
     use `openlog', you must call `closelog' before any point where
     your library might get unloaded, as in this example:

          #include <syslog.h>

          void
          shared_library_function (void)
          {
            openlog ("mylibrary", option, priority);

            syslog (LOG_INFO, "shared library has been invoked");

            closelog ();
          }

     Without the call to `closelog', future invocations of `syslog' by
     the program using the shared library may crash, if the library gets
     unloaded and the memory containing the string `"mylibrary"' becomes
     unmapped.  This is a limitation of the BSD syslog interface.

     `openlog' may or may not open the `/dev/log' socket, depending on
     OPTION.  If it does, it tries to open it and connect it as a
     stream socket.  If that doesn't work, it tries to open it and
     connect it as a datagram socket.  The socket has the "Close on
     Exec" attribute, so the kernel will close it if the process
     performs an exec.

     You don't have to use `openlog'.  If you call `syslog' without
     having called `openlog', `syslog' just opens the connection
     implicitly and uses defaults for the information in IDENT and
     OPTIONS.

     OPTIONS is a bit string, with the bits as defined by the following
     single bit masks:

    `LOG_PERROR'
          If on, `openlog' sets up the connection so that any `syslog'
          on this connection writes its message to the calling process'
          Standard Error stream in addition to submitting it to Syslog.
          If off, `syslog' does not write the message to Standard Error.

    `LOG_CONS'
          If on, `openlog' sets up the connection so that a `syslog' on
          this connection that fails to submit a message to Syslog
          writes the message instead to system console.  If off,
          `syslog' does not write to the system console (but of course
          Syslog may write messages it receives to the console).

    `LOG_PID'
          When on, `openlog' sets up the connection so that a `syslog'
          on this connection inserts the calling process' Process ID
          (PID) into the message.  When off, `openlog' does not insert
          the PID.

    `LOG_NDELAY'
          When on, `openlog' opens and connects the `/dev/log' socket.
          When off, a future `syslog' call must open and connect the
          socket.

          *Portability note:*  In early systems, the sense of this bit
          was exactly the opposite.

    `LOG_ODELAY'
          This bit does nothing.  It exists for backward compatibility.


     If any other bit in OPTIONS is on, the result is undefined.

     FACILITY is the default facility code for this connection.  A
     `syslog' on this connection that specifies default facility causes
     this facility to be associated with the message.  See `syslog' for
     possible values.  A value of zero means the default default, which
     is `LOG_USER'.

     If a Syslog connection is already open when you call `openlog',
     `openlog' "reopens" the connection.  Reopening is like opening
     except that if you specify zero for the default facility code, the
     default facility code simply remains unchanged and if you specify
     LOG_NDELAY and the socket is already open and connected, `openlog'
     just leaves it that way.



File: libc.info,  Node: syslog; vsyslog,  Next: closelog,  Prev: openlog,  Up: Submitting Syslog Messages

18.2.2 syslog, vsyslog
----------------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: void syslog (int FACILITY_PRIORITY, char *FORMAT, ...)
     `syslog' submits a message to the Syslog facility.  It does this by
     writing to the Unix domain socket `/dev/log'.

     `syslog' submits the message with the facility and priority
     indicated by FACILITY_PRIORITY.  The macro `LOG_MAKEPRI' generates
     a facility/priority from a facility and a priority, as in the
     following example:

          LOG_MAKEPRI(LOG_USER, LOG_WARNING)

     The possible values for the facility code are (macros):

    `LOG_USER'
          A miscellaneous user process

    `LOG_MAIL'
          Mail

    `LOG_DAEMON'
          A miscellaneous system daemon

    `LOG_AUTH'
          Security (authorization)

    `LOG_SYSLOG'
          Syslog

    `LOG_LPR'
          Central printer

    `LOG_NEWS'
          Network news (e.g. Usenet)

    `LOG_UUCP'
          UUCP

    `LOG_CRON'
          Cron and At

    `LOG_AUTHPRIV'
          Private security (authorization)

    `LOG_FTP'
          Ftp server

    `LOG_LOCAL0'
          Locally defined

    `LOG_LOCAL1'
          Locally defined

    `LOG_LOCAL2'
          Locally defined

    `LOG_LOCAL3'
          Locally defined

    `LOG_LOCAL4'
          Locally defined

    `LOG_LOCAL5'
          Locally defined

    `LOG_LOCAL6'
          Locally defined

    `LOG_LOCAL7'
          Locally defined

     Results are undefined if the facility code is anything else.

     *NB:* `syslog' recognizes one other facility code: that of the
     kernel.  But you can't specify that facility code with these
     functions.  If you try, it looks the same to `syslog' as if you are
     requesting the default facility.  But you wouldn't want to anyway,
     because any program that uses the GNU C library is not the kernel.

     You can use just a priority code as FACILITY_PRIORITY.  In that
     case, `syslog' assumes the default facility established when the
     Syslog connection was opened.  *Note Syslog Example::.

     The possible values for the priority code are (macros):

    `LOG_EMERG'
          The message says the system is unusable.

    `LOG_ALERT'
          Action on the message must be taken immediately.

    `LOG_CRIT'
          The message states a critical condition.

    `LOG_ERR'
          The message describes an error.

    `LOG_WARNING'
          The message is a warning.

    `LOG_NOTICE'
          The message describes a normal but important event.

    `LOG_INFO'
          The message is purely informational.

    `LOG_DEBUG'
          The message is only for debugging purposes.

     Results are undefined if the priority code is anything else.

     If the process does not presently have a Syslog connection open
     (i.e., it did not call `openlog'), `syslog' implicitly opens the
     connection the same as `openlog' would, with the following defaults
     for information that would otherwise be included in an `openlog'
     call: The default identification string is the program name.  The
     default default facility is `LOG_USER'.  The default for all the
     connection options in OPTIONS is as if those bits were off.
     `syslog' leaves the Syslog connection open.

     If the `dev/log' socket is not open and connected, `syslog' opens
     and connects it, the same as `openlog' with the `LOG_NDELAY'
     option would.

     `syslog' leaves `/dev/log' open and connected unless its attempt
     to send the message failed, in which case `syslog' closes it (with
     the hope that a future implicit open will restore the Syslog
     connection to a usable state).

     Example:


          #include <syslog.h>
          syslog (LOG_MAKEPRI(LOG_LOCAL1, LOG_ERROR),
                  "Unable to make network connection to %s.  Error=%m", host);


 -- Function: void vsyslog (int FACILITY_PRIORITY, char *FORMAT,
          va_list arglist)
     This is functionally identical to `syslog', with the BSD style
     variable length argument.



File: libc.info,  Node: closelog,  Next: setlogmask,  Prev: syslog; vsyslog,  Up: Submitting Syslog Messages

18.2.3 closelog
---------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: void closelog (void)
     `closelog' closes the current Syslog connection, if there is one.
     This includes closing the `dev/log' socket, if it is open.
     `closelog' also sets the identification string for Syslog messages
     back to the default, if `openlog' was called with a non-NULL
     argument to IDENT.  The default identification string is the
     program name taken from argv[0].

     If you are writing shared library code that uses `openlog' to
     generate custom syslog output, you should use `closelog' to drop
     the GNU C library's internal reference to the IDENT pointer when
     you are done.  Please read the section on `openlog' for more
     information: *Note openlog::.

     `closelog' does not flush any buffers.  You do not have to call
     `closelog' before re-opening a Syslog connection with `initlog'.
     Syslog connections are automatically closed on exec or exit.



File: libc.info,  Node: setlogmask,  Next: Syslog Example,  Prev: closelog,  Up: Submitting Syslog Messages

18.2.4 setlogmask
-----------------

The symbols referred to in this section are declared in the file
`syslog.h'.

 -- Function: int setlogmask (int MASK)
     `setlogmask' sets a mask (the "logmask") that determines which
     future `syslog' calls shall be ignored.  If a program has not
     called `setlogmask', `syslog' doesn't ignore any calls.  You can
     use `setlogmask' to specify that messages of particular priorities
     shall be ignored in the future.

     A `setlogmask' call overrides any previous `setlogmask' call.

     Note that the logmask exists entirely independently of opening and
     closing of Syslog connections.

     Setting the logmask has a similar effect to, but is not the same
     as, configuring Syslog.  The Syslog configuration may cause Syslog
     to discard certain messages it receives, but the logmask causes
     certain messages never to get submitted to Syslog in the first
     place.

     MASK is a bit string with one bit corresponding to each of the
     possible message priorities.  If the bit is on, `syslog' handles
     messages of that priority normally.  If it is off, `syslog'
     discards messages of that priority.  Use the message priority
     macros described in *note syslog; vsyslog:: and the `LOG_MASK' to
     construct an appropriate MASK value, as in this example:

          LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ERROR)

     or

          ~(LOG_MASK(LOG_INFO))

     There is also a `LOG_UPTO' macro, which generates a mask with the
     bits on for a certain priority and all priorities above it:

          LOG_UPTO(LOG_ERROR)

     The unfortunate naming of the macro is due to the fact that
     internally, higher numbers are used for lower message priorities.



File: libc.info,  Node: Syslog Example,  Prev: setlogmask,  Up: Submitting Syslog Messages

18.2.5 Syslog Example
---------------------

Here is an example of `openlog', `syslog', and `closelog':

   This example sets the logmask so that debug and informational
messages get discarded without ever reaching Syslog.  So the second
`syslog' in the example does nothing.

     #include <syslog.h>

     setlogmask (LOG_UPTO (LOG_NOTICE));

     openlog ("exampleprog", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);

     syslog (LOG_NOTICE, "Program started by User %d", getuid ());
     syslog (LOG_INFO, "A tree falls in a forest");

     closelog ();


File: libc.info,  Node: Mathematics,  Next: Arithmetic,  Prev: Syslog,  Up: Top

19 Mathematics
**************

This chapter contains information about functions for performing
mathematical computations, such as trigonometric functions.  Most of
these functions have prototypes declared in the header file `math.h'.
The complex-valued functions are defined in `complex.h'.  

   All mathematical functions which take a floating-point argument have
three variants, one each for `double', `float', and `long double'
arguments.  The `double' versions are mostly defined in ISO C89.  The
`float' and `long double' versions are from the numeric extensions to C
included in ISO C99.

   Which of the three versions of a function should be used depends on
the situation.  For most calculations, the `float' functions are the
fastest.  On the other hand, the `long double' functions have the
highest precision.  `double' is somewhere in between.  It is usually
wise to pick the narrowest type that can accommodate your data.  Not
all machines have a distinct `long double' type; it may be the same as
`double'.

* Menu:

* Mathematical Constants::      Precise numeric values for often-used
                                 constants.
* Trig Functions::              Sine, cosine, tangent, and friends.
* Inverse Trig Functions::      Arcsine, arccosine, etc.
* Exponents and Logarithms::    Also pow and sqrt.
* Hyperbolic Functions::        sinh, cosh, tanh, etc.
* Special Functions::           Bessel, gamma, erf.
* Errors in Math Functions::    Known Maximum Errors in Math Functions.
* Pseudo-Random Numbers::       Functions for generating pseudo-random
				 numbers.
* FP Function Optimizations::   Fast code or small code.


File: libc.info,  Node: Mathematical Constants,  Next: Trig Functions,  Up: Mathematics

19.1 Predefined Mathematical Constants
======================================

The header `math.h' defines several useful mathematical constants.  All
values are defined as preprocessor macros starting with `M_'.  The
values provided are:

`M_E'
     The base of natural logarithms.

`M_LOG2E'
     The logarithm to base `2' of `M_E'.

`M_LOG10E'
     The logarithm to base `10' of `M_E'.

`M_LN2'
     The natural logarithm of `2'.

`M_LN10'
     The natural logarithm of `10'.

`M_PI'
     Pi, the ratio of a circle's circumference to its diameter.

`M_PI_2'
     Pi divided by two.

`M_PI_4'
     Pi divided by four.

`M_1_PI'
     The reciprocal of pi (1/pi)

`M_2_PI'
     Two times the reciprocal of pi.

`M_2_SQRTPI'
     Two times the reciprocal of the square root of pi.

`M_SQRT2'
     The square root of two.

`M_SQRT1_2'
     The reciprocal of the square root of two (also the square root of
     1/2).

   These constants come from the Unix98 standard and were also
available in 4.4BSD; therefore they are only defined if `_BSD_SOURCE' or
`_XOPEN_SOURCE=500', or a more general feature select macro, is
defined.  The default set of features includes these constants.  *Note
Feature Test Macros::.

   All values are of type `double'.  As an extension, the GNU C library
also defines these constants with type `long double'.  The `long
double' macros have a lowercase `l' appended to their names: `M_El',
`M_PIl', and so forth.  These are only available if `_GNU_SOURCE' is
defined.

   _Note:_ Some programs use a constant named `PI' which has the same
value as `M_PI'.  This constant is not standard; it may have appeared
in some old AT&T headers, and is mentioned in Stroustrup's book on C++.
It infringes on the user's name space, so the GNU C library does not
define it.  Fixing programs written to expect it is simple: replace
`PI' with `M_PI' throughout, or put `-DPI=M_PI' on the compiler command
line.


File: libc.info,  Node: Trig Functions,  Next: Inverse Trig Functions,  Prev: Mathematical Constants,  Up: Mathematics

19.2 Trigonometric Functions
============================

These are the familiar `sin', `cos', and `tan' functions.  The
arguments to all of these functions are in units of radians; recall
that pi radians equals 180 degrees.

   The math library normally defines `M_PI' to a `double' approximation
of pi.  If strict ISO and/or POSIX compliance are requested this
constant is not defined, but you can easily define it yourself:

     #define M_PI 3.14159265358979323846264338327

You can also compute the value of pi with the expression `acos (-1.0)'.

 -- Function: double sin (double X)
 -- Function: float sinf (float X)
 -- Function: long double sinl (long double X)
     These functions return the sine of X, where X is given in radians.
     The return value is in the range `-1' to `1'.

 -- Function: double cos (double X)
 -- Function: float cosf (float X)
 -- Function: long double cosl (long double X)
     These functions return the cosine of X, where X is given in
     radians.  The return value is in the range `-1' to `1'.

 -- Function: double tan (double X)
 -- Function: float tanf (float X)
 -- Function: long double tanl (long double X)
     These functions return the tangent of X, where X is given in
     radians.

     Mathematically, the tangent function has singularities at odd
     multiples of pi/2.  If the argument X is too close to one of these
     singularities, `tan' will signal overflow.

   In many applications where `sin' and `cos' are used, the sine and
cosine of the same angle are needed at the same time.  It is more
efficient to compute them simultaneously, so the library provides a
function to do that.

 -- Function: void sincos (double X, double *SINX, double *COSX)
 -- Function: void sincosf (float X, float *SINX, float *COSX)
 -- Function: void sincosl (long double X, long double *SINX, long
          double *COSX)
     These functions return the sine of X in `*SINX' and the cosine of
     X in `*COS', where X is given in radians.  Both values, `*SINX'
     and `*COSX', are in the range of `-1' to `1'.

     This function is a GNU extension.  Portable programs should be
     prepared to cope with its absence.

   ISO C99 defines variants of the trig functions which work on complex
numbers.  The GNU C library provides these functions, but they are only
useful if your compiler supports the new complex types defined by the
standard.  (As of this writing GCC supports complex numbers, but there
are bugs in the implementation.)

 -- Function: complex double csin (complex double Z)
 -- Function: complex float csinf (complex float Z)
 -- Function: complex long double csinl (complex long double Z)
     These functions return the complex sine of Z.  The mathematical
     definition of the complex sine is

     sin (z) = 1/(2*i) * (exp (z*i) - exp (-z*i)).

 -- Function: complex double ccos (complex double Z)
 -- Function: complex float ccosf (complex float Z)
 -- Function: complex long double ccosl (complex long double Z)
     These functions return the complex cosine of Z.  The mathematical
     definition of the complex cosine is

     cos (z) = 1/2 * (exp (z*i) + exp (-z*i))

 -- Function: complex double ctan (complex double Z)
 -- Function: complex float ctanf (complex float Z)
 -- Function: complex long double ctanl (complex long double Z)
     These functions return the complex tangent of Z.  The mathematical
     definition of the complex tangent is

     tan (z) = -i * (exp (z*i) - exp (-z*i)) / (exp (z*i) + exp (-z*i))

     The complex tangent has poles at pi/2 + 2n, where n is an integer.
     `ctan' may signal overflow if Z is too close to a pole.


File: libc.info,  Node: Inverse Trig Functions,  Next: Exponents and Logarithms,  Prev: Trig Functions,  Up: Mathematics

19.3 Inverse Trigonometric Functions
====================================

These are the usual arc sine, arc cosine and arc tangent functions,
which are the inverses of the sine, cosine and tangent functions
respectively.

 -- Function: double asin (double X)
 -- Function: float asinf (float X)
 -- Function: long double asinl (long double X)
     These functions compute the arc sine of X--that is, the value whose
     sine is X.  The value is in units of radians.  Mathematically,
     there are infinitely many such values; the one actually returned
     is the one between `-pi/2' and `pi/2' (inclusive).

     The arc sine function is defined mathematically only over the
     domain `-1' to `1'.  If X is outside the domain, `asin' signals a
     domain error.

 -- Function: double acos (double X)
 -- Function: float acosf (float X)
 -- Function: long double acosl (long double X)
     These functions compute the arc cosine of X--that is, the value
     whose cosine is X.  The value is in units of radians.
     Mathematically, there are infinitely many such values; the one
     actually returned is the one between `0' and `pi' (inclusive).

     The arc cosine function is defined mathematically only over the
     domain `-1' to `1'.  If X is outside the domain, `acos' signals a
     domain error.

 -- Function: double atan (double X)
 -- Function: float atanf (float X)
 -- Function: long double atanl (long double X)
     These functions compute the arc tangent of X--that is, the value
     whose tangent is X.  The value is in units of radians.
     Mathematically, there are infinitely many such values; the one
     actually returned is the one between `-pi/2' and `pi/2'
     (inclusive).

 -- Function: double atan2 (double Y, double X)
 -- Function: float atan2f (float Y, float X)
 -- Function: long double atan2l (long double Y, long double X)
     This function computes the arc tangent of Y/X, but the signs of
     both arguments are used to determine the quadrant of the result,
     and X is permitted to be zero.  The return value is given in
     radians and is in the range `-pi' to `pi', inclusive.

     If X and Y are coordinates of a point in the plane, `atan2'
     returns the signed angle between the line from the origin to that
     point and the x-axis.  Thus, `atan2' is useful for converting
     Cartesian coordinates to polar coordinates.  (To compute the
     radial coordinate, use `hypot'; see *note Exponents and
     Logarithms::.)

     If both X and Y are zero, `atan2' returns zero.

   ISO C99 defines complex versions of the inverse trig functions.

 -- Function: complex double casin (complex double Z)
 -- Function: complex float casinf (complex float Z)
 -- Function: complex long double casinl (complex long double Z)
     These functions compute the complex arc sine of Z--that is, the
     value whose sine is Z.  The value returned is in radians.

     Unlike the real-valued functions, `casin' is defined for all
     values of Z.

 -- Function: complex double cacos (complex double Z)
 -- Function: complex float cacosf (complex float Z)
 -- Function: complex long double cacosl (complex long double Z)
     These functions compute the complex arc cosine of Z--that is, the
     value whose cosine is Z.  The value returned is in radians.

     Unlike the real-valued functions, `cacos' is defined for all
     values of Z.

 -- Function: complex double catan (complex double Z)
 -- Function: complex float catanf (complex float Z)
 -- Function: complex long double catanl (complex long double Z)
     These functions compute the complex arc tangent of Z--that is, the
     value whose tangent is Z.  The value is in units of radians.


File: libc.info,  Node: Exponents and Logarithms,  Next: Hyperbolic Functions,  Prev: Inverse Trig Functions,  Up: Mathematics

19.4 Exponentiation and Logarithms
==================================

 -- Function: double exp (double X)
 -- Function: float expf (float X)
 -- Function: long double expl (long double X)
     These functions compute `e' (the base of natural logarithms) raised
     to the power X.

     If the magnitude of the result is too large to be representable,
     `exp' signals overflow.

 -- Function: double exp2 (double X)
 -- Function: float exp2f (float X)
 -- Function: long double exp2l (long double X)
     These functions compute `2' raised to the power X.
     Mathematically, `exp2 (x)' is the same as `exp (x * log (2))'.

 -- Function: double exp10 (double X)
 -- Function: float exp10f (float X)
 -- Function: long double exp10l (long double X)
 -- Function: double pow10 (double X)
 -- Function: float pow10f (float X)
 -- Function: long double pow10l (long double X)
     These functions compute `10' raised to the power X.
     Mathematically, `exp10 (x)' is the same as `exp (x * log (10))'.

     These functions are GNU extensions.  The name `exp10' is
     preferred, since it is analogous to `exp' and `exp2'.

 -- Function: double log (double X)
 -- Function: float logf (float X)
 -- Function: long double logl (long double X)
     These functions compute the natural logarithm of X.  `exp (log
     (X))' equals X, exactly in mathematics and approximately in C.

     If X is negative, `log' signals a domain error.  If X is zero, it
     returns negative infinity; if X is too close to zero, it may
     signal overflow.

 -- Function: double log10 (double X)
 -- Function: float log10f (float X)
 -- Function: long double log10l (long double X)
     These functions return the base-10 logarithm of X.  `log10 (X)'
     equals `log (X) / log (10)'.


 -- Function: double log2 (double X)
 -- Function: float log2f (float X)
 -- Function: long double log2l (long double X)
     These functions return the base-2 logarithm of X.  `log2 (X)'
     equals `log (X) / log (2)'.

 -- Function: double logb (double X)
 -- Function: float logbf (float X)
 -- Function: long double logbl (long double X)
     These functions extract the exponent of X and return it as a
     floating-point value.  If `FLT_RADIX' is two, `logb' is equal to
     `floor (log2 (x))', except it's probably faster.

     If X is de-normalized, `logb' returns the exponent X would have if
     it were normalized.  If X is infinity (positive or negative),
     `logb' returns oo.  If X is zero, `logb' returns oo.  It does not
     signal.

 -- Function: int ilogb (double X)
 -- Function: int ilogbf (float X)
 -- Function: int ilogbl (long double X)
     These functions are equivalent to the corresponding `logb'
     functions except that they return signed integer values.

Since integers cannot represent infinity and NaN, `ilogb' instead
returns an integer that can't be the exponent of a normal floating-point
number.  `math.h' defines constants so you can check for this.

 -- Macro: int FP_ILOGB0
     `ilogb' returns this value if its argument is `0'.  The numeric
     value is either `INT_MIN' or `-INT_MAX'.

     This macro is defined in ISO C99.

 -- Macro: int FP_ILOGBNAN
     `ilogb' returns this value if its argument is `NaN'.  The numeric
     value is either `INT_MIN' or `INT_MAX'.

     This macro is defined in ISO C99.

   These values are system specific.  They might even be the same.  The
proper way to test the result of `ilogb' is as follows:

     i = ilogb (f);
     if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
       {
         if (isnan (f))
           {
             /* Handle NaN.  */
           }
         else if (f  == 0.0)
           {
             /* Handle 0.0.  */
           }
         else
           {
             /* Some other value with large exponent,
                perhaps +Inf.  */
           }
       }

 -- Function: double pow (double BASE, double POWER)
 -- Function: float powf (float BASE, float POWER)
 -- Function: long double powl (long double BASE, long double POWER)
     These are general exponentiation functions, returning BASE raised
     to POWER.

     Mathematically, `pow' would return a complex number when BASE is
     negative and POWER is not an integral value.  `pow' can't do that,
     so instead it signals a domain error. `pow' may also underflow or
     overflow the destination type.

 -- Function: double sqrt (double X)
 -- Function: float sqrtf (float X)
 -- Function: long double sqrtl (long double X)
     These functions return the nonnegative square root of X.

     If X is negative, `sqrt' signals a domain error.  Mathematically,
     it should return a complex number.

 -- Function: double cbrt (double X)
 -- Function: float cbrtf (float X)
 -- Function: long double cbrtl (long double X)
     These functions return the cube root of X.  They cannot fail;
     every representable real value has a representable real cube root.

 -- Function: double hypot (double X, double Y)
 -- Function: float hypotf (float X, float Y)
 -- Function: long double hypotl (long double X, long double Y)
     These functions return `sqrt (X*X + Y*Y)'.  This is the length of
     the hypotenuse of a right triangle with sides of length X and Y,
     or the distance of the point (X, Y) from the origin.  Using this
     function instead of the direct formula is wise, since the error is
     much smaller.  See also the function `cabs' in *note Absolute
     Value::.

 -- Function: double expm1 (double X)
 -- Function: float expm1f (float X)
 -- Function: long double expm1l (long double X)
     These functions return a value equivalent to `exp (X) - 1'.  They
     are computed in a way that is accurate even if X is near zero--a
     case where `exp (X) - 1' would be inaccurate owing to subtraction
     of two numbers that are nearly equal.

 -- Function: double log1p (double X)
 -- Function: float log1pf (float X)
 -- Function: long double log1pl (long double X)
     These functions returns a value equivalent to `log (1 + X)'.  They
     are computed in a way that is accurate even if X is near zero.

   ISO C99 defines complex variants of some of the exponentiation and
logarithm functions.

 -- Function: complex double cexp (complex double Z)
 -- Function: complex float cexpf (complex float Z)
 -- Function: complex long double cexpl (complex long double Z)
     These functions return `e' (the base of natural logarithms) raised
     to the power of Z.  Mathematically, this corresponds to the value

     exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))

 -- Function: complex double clog (complex double Z)
 -- Function: complex float clogf (complex float Z)
 -- Function: complex long double clogl (complex long double Z)
     These functions return the natural logarithm of Z.
     Mathematically, this corresponds to the value

     log (z) = log (cabs (z)) + I * carg (z)

     `clog' has a pole at 0, and will signal overflow if Z equals or is
     very close to 0.  It is well-defined for all other values of Z.

 -- Function: complex double clog10 (complex double Z)
 -- Function: complex float clog10f (complex float Z)
 -- Function: complex long double clog10l (complex long double Z)
     These functions return the base 10 logarithm of the complex value
     Z. Mathematically, this corresponds to the value

     log (z) = log10 (cabs (z)) + I * carg (z)

     These functions are GNU extensions.

 -- Function: complex double csqrt (complex double Z)
 -- Function: complex float csqrtf (complex float Z)
 -- Function: complex long double csqrtl (complex long double Z)
     These functions return the complex square root of the argument Z.
     Unlike the real-valued functions, they are defined for all values
     of Z.

 -- Function: complex double cpow (complex double BASE, complex double
          POWER)
 -- Function: complex float cpowf (complex float BASE, complex float
          POWER)
 -- Function: complex long double cpowl (complex long double BASE,
          complex long double POWER)
     These functions return BASE raised to the power of POWER.  This is
     equivalent to `cexp (y * clog (x))'


File: libc.info,  Node: Hyperbolic Functions,  Next: Special Functions,  Prev: Exponents and Logarithms,  Up: Mathematics

19.5 Hyperbolic Functions
=========================

The functions in this section are related to the exponential functions;
see *note Exponents and Logarithms::.

 -- Function: double sinh (double X)
 -- Function: float sinhf (float X)
 -- Function: long double sinhl (long double X)
     These functions return the hyperbolic sine of X, defined
     mathematically as `(exp (X) - exp (-X)) / 2'.  They may signal
     overflow if X is too large.

 -- Function: double cosh (double X)
 -- Function: float coshf (float X)
 -- Function: long double coshl (long double X)
     These function return the hyperbolic cosine of X, defined
     mathematically as `(exp (X) + exp (-X)) / 2'.  They may signal
     overflow if X is too large.

 -- Function: double tanh (double X)
 -- Function: float tanhf (float X)
 -- Function: long double tanhl (long double X)
     These functions return the hyperbolic tangent of X, defined
     mathematically as `sinh (X) / cosh (X)'.  They may signal overflow
     if X is too large.

   There are counterparts for the hyperbolic functions which take
complex arguments.

 -- Function: complex double csinh (complex double Z)
 -- Function: complex float csinhf (complex float Z)
 -- Function: complex long double csinhl (complex long double Z)
     These functions return the complex hyperbolic sine of Z, defined
     mathematically as `(exp (Z) - exp (-Z)) / 2'.

 -- Function: complex double ccosh (complex double Z)
 -- Function: complex float ccoshf (complex float Z)
 -- Function: complex long double ccoshl (complex long double Z)
     These functions return the complex hyperbolic cosine of Z, defined
     mathematically as `(exp (Z) + exp (-Z)) / 2'.

 -- Function: complex double ctanh (complex double Z)
 -- Function: complex float ctanhf (complex float Z)
 -- Function: complex long double ctanhl (complex long double Z)
     These functions return the complex hyperbolic tangent of Z,
     defined mathematically as `csinh (Z) / ccosh (Z)'.

 -- Function: double asinh (double X)
 -- Function: float asinhf (float X)
 -- Function: long double asinhl (long double X)
     These functions return the inverse hyperbolic sine of X--the value
     whose hyperbolic sine is X.

 -- Function: double acosh (double X)
 -- Function: float acoshf (float X)
 -- Function: long double acoshl (long double X)
     These functions return the inverse hyperbolic cosine of X--the
     value whose hyperbolic cosine is X.  If X is less than `1',
     `acosh' signals a domain error.

 -- Function: double atanh (double X)
 -- Function: float atanhf (float X)
 -- Function: long double atanhl (long double X)
     These functions return the inverse hyperbolic tangent of X--the
     value whose hyperbolic tangent is X.  If the absolute value of X
     is greater than `1', `atanh' signals a domain error; if it is
     equal to 1, `atanh' returns infinity.

 -- Function: complex double casinh (complex double Z)
 -- Function: complex float casinhf (complex float Z)
 -- Function: complex long double casinhl (complex long double Z)
     These functions return the inverse complex hyperbolic sine of
     Z--the value whose complex hyperbolic sine is Z.

 -- Function: complex double cacosh (complex double Z)
 -- Function: complex float cacoshf (complex float Z)
 -- Function: complex long double cacoshl (complex long double Z)
     These functions return the inverse complex hyperbolic cosine of
     Z--the value whose complex hyperbolic cosine is Z.  Unlike the
     real-valued functions, there are no restrictions on the value of Z.

 -- Function: complex double catanh (complex double Z)
 -- Function: complex float catanhf (complex float Z)
 -- Function: complex long double catanhl (complex long double Z)
     These functions return the inverse complex hyperbolic tangent of
     Z--the value whose complex hyperbolic tangent is Z.  Unlike the
     real-valued functions, there are no restrictions on the value of Z.


File: libc.info,  Node: Special Functions,  Next: Errors in Math Functions,  Prev: Hyperbolic Functions,  Up: Mathematics

19.6 Special Functions
======================

These are some more exotic mathematical functions which are sometimes
useful.  Currently they only have real-valued versions.

 -- Function: double erf (double X)
 -- Function: float erff (float X)
 -- Function: long double erfl (long double X)
     `erf' returns the error function of X.  The error function is
     defined as
          erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt

 -- Function: double erfc (double X)
 -- Function: float erfcf (float X)
 -- Function: long double erfcl (long double X)
     `erfc' returns `1.0 - erf(X)', but computed in a fashion that
     avoids round-off error when X is large.

 -- Function: double lgamma (double X)
 -- Function: float lgammaf (float X)
 -- Function: long double lgammal (long double X)
     `lgamma' returns the natural logarithm of the absolute value of
     the gamma function of X.  The gamma function is defined as
          gamma (x) = integral from 0 to oo of t^(x-1) e^-t dt

     The sign of the gamma function is stored in the global variable
     SIGNGAM, which is declared in `math.h'.  It is `1' if the
     intermediate result was positive or zero, or `-1' if it was
     negative.

     To compute the real gamma function you can use the `tgamma'
     function or you can compute the values as follows:
          lgam = lgamma(x);
          gam  = signgam*exp(lgam);

     The gamma function has singularities at the non-positive integers.
     `lgamma' will raise the zero divide exception if evaluated at a
     singularity.

 -- Function: double lgamma_r (double X, int *SIGNP)
 -- Function: float lgammaf_r (float X, int *SIGNP)
 -- Function: long double lgammal_r (long double X, int *SIGNP)
     `lgamma_r' is just like `lgamma', but it stores the sign of the
     intermediate result in the variable pointed to by SIGNP instead of
     in the SIGNGAM global.  This means it is reentrant.

 -- Function: double gamma (double X)
 -- Function: float gammaf (float X)
 -- Function: long double gammal (long double X)
     These functions exist for compatibility reasons.  They are
     equivalent to `lgamma' etc.  It is better to use `lgamma' since
     for one the name reflects better the actual computation, moreover
     `lgamma' is standardized in ISO C99 while `gamma' is not.

 -- Function: double tgamma (double X)
 -- Function: float tgammaf (float X)
 -- Function: long double tgammal (long double X)
     `tgamma' applies the gamma function to X.  The gamma function is
     defined as
          gamma (x) = integral from 0 to oo of t^(x-1) e^-t dt

     This function was introduced in ISO C99.

 -- Function: double j0 (double X)
 -- Function: float j0f (float X)
 -- Function: long double j0l (long double X)
     `j0' returns the Bessel function of the first kind of order 0 of
     X.  It may signal underflow if X is too large.

 -- Function: double j1 (double X)
 -- Function: float j1f (float X)
 -- Function: long double j1l (long double X)
     `j1' returns the Bessel function of the first kind of order 1 of
     X.  It may signal underflow if X is too large.

 -- Function: double jn (int n, double X)
 -- Function: float jnf (int n, float X)
 -- Function: long double jnl (int n, long double X)
     `jn' returns the Bessel function of the first kind of order N of
     X.  It may signal underflow if X is too large.

 -- Function: double y0 (double X)
 -- Function: float y0f (float X)
 -- Function: long double y0l (long double X)
     `y0' returns the Bessel function of the second kind of order 0 of
     X.  It may signal underflow if X is too large.  If X is negative,
     `y0' signals a domain error; if it is zero, `y0' signals overflow
     and returns -oo.

 -- Function: double y1 (double X)
 -- Function: float y1f (float X)
 -- Function: long double y1l (long double X)
     `y1' returns the Bessel function of the second kind of order 1 of
     X.  It may signal underflow if X is too large.  If X is negative,
     `y1' signals a domain error; if it is zero, `y1' signals overflow
     and returns -oo.

 -- Function: double yn (int n, double X)
 -- Function: float ynf (int n, float X)
 -- Function: long double ynl (int n, long double X)
     `yn' returns the Bessel function of the second kind of order N of
     X.  It may signal underflow if X is too large.  If X is negative,
     `yn' signals a domain error; if it is zero, `yn' signals overflow
     and returns -oo.

